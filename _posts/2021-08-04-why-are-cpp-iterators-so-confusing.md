---
layout: post
title: "C++ 반복자는 왜 그렇게 헷갈리는 걸까?"
tags:
- Language
style: "/assets/post-styles/why-are-cpp-iterators-so-confusing.css"
script: "/assets/post-scripts/why-are-cpp-iterators-so-confusing.js"
# comments: true

category:
- Beta
---

* _**이 글은 링크로만 접근할 수 있는 베타 버전입니다.** 글을 미리 읽어보고 피드백을 남겨 주시면 감사하겠습니다._

**이 글은 키보드로만 조작할 수 있는 인터랙티브 요소를 포함하고 있으며, 모바일 환경에 최적화되지 않았습니다. PC로 열람을 권장합니다.**

에츠허르 다익스트라는 [Why numbering should start at zero](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html)라는 서한을 남긴 적이 있습니다. 전체 내용을 최선을 다해 번역하면 다음과 같습니다.

> <u>번호 붙이기를 0부터 시작해야 하는 이유</u>
>
> 자연수의 부분수열 2, 3, ..., 12를 끔찍한 줄임표 없이 나타낼 때, 다음과 같은 4종류의 방식을 고를 수 있다.
>
> * a) 2 &le; i < 13
> * b) 1 < i &le; 12
> * c) 2 &le; i &le; 12
> * d) 1 < i < 13
>
> 이 중 특정한 방식을 다른 것보다 선호할 이유가 있는가? 그렇다. 방식 a)와 b)는 표기된 상·하한의 차가 부분수열의 길이와 같은 이점이 있다는 관찰은 타당하다. 또한 결과적으로 이들 방식 하에서 두 부분수열이 인접하면 한쪽의 상한이 다른 한쪽의 하한과 같아진다는 관찰 역시 타당하다.[^tn-adjacent-subsequences] 그러나 이러한 관찰이 타당한 것과 별개로 a)와 b) 중 더 나은 것을 고를 수는 없으니, 원점으로 돌아가 보자.
>
> 자연수에는 최솟값이 존재한다. b)와 d)와 같이 하한을 제외할 경우 가장 작은 자연수부터 시작하는 부분수열의 하한이 비자연수가 되어야 한다.[^tn-left-exclusive] 이는 더러우니 하한은 a)와 c)처럼 &le;로 표기하는 것을 선호한다. 한편 가장 작은 자연수부터 시작하는 부분수열을 생각하자. 상한을 포함할 경우 부분수열이 빈 수열이 되었을 때 상한이 비자연수가 되어야 한다.[^tn-right-inclusive] 이는 더러우니 상한은 a)와 d)처럼 <로 표기하는 것을 선호한다. 이로써 방식 a)를 가장 우선하는 것으로 결론지을 수 있다.
>
> <u>참고</u> Xerox PARC에서 개발한 프로그래밍 언어 Mesa에는 네 종류의 방식 전부를 이용해 구간을 표현하는 특수 문법이 있다. Mesa를 이용한 광범위한 실험에서 나머지 세 방식이 꾸준히 어색한 코드와 실수의 원인이 되어 왔음이 밝혀졌으며, 이 실험으로 인해 현재 Mesa 프로그래밍을 할 때는 나머지 세 문법을 사용하지 않는 것이 권장되고 있다. 도움이 될지 모르겠지만, 내가 이 실험적 증거를 언급하는 이유는 현장에서 검증되지 않은 결론을 불편해하는 사람들이 있기 때문이다. (참고 끝.)
>
> ***
>
> 길이가 *N*인 수열의 원소를 첨자로 구분하려고 할 때, 그 다음으로 난감한 문제는 첫 원소에 무슨 첨자 값을 대응시킬지에 대해서이다. 방식 a)를 따를 때, 첨자가 1부터 시작하면 첨자의 범위가 1 &le; i < *N*+1이 되지만 0부터 시작하면 더욱 보기 좋은 범위인 0 &le; i < *N*이 된다. 그러니 서수는 0부터 시작하는 것으로 하자. 그러면 어떤 원소의 서수(첨자)가 그 수열에서 더 앞에 있는 원소의 개수와 같아진다. 또 이 이야기의 교훈은, (그 몇백 년\[간의 논쟁?\] 끝에!) 0을 가장 자연스러운 자연수로 취급하는 것이 낫다는 것이다.
>
> <u>참고</u> 여러 프로그래밍 언어가 이러한 세부사항에 주목하지 않고 설계되었다. FORTRAN에서는 첨자가 항상 1부터 시작하고, ALGOL 60과 PASCAL에서는 방식 c)를 채택했으며, 더 최근의 SASL은 FORTRAN 방식으로 회귀했다. SASL의 수열은 동시에 양의 정수의 함수이기도 하다. 유감! (참고 끝.)
>
> ***
>
> 위의 이야기를 하자니 최근에 우리 대학의 수학과 동료 중 한 명(컴퓨터과학자 아님)가 몇몇 젊은 컴퓨터과학자들을 (습관적으로) 수를 0부터 센다는 이유로 "꼰대"라고 하던 일이 생각난다. 가장 합리적인 방식을 의식적으로 받아들이는 것을 화낼 이유로 받아들인 것이다. ("○○ 끝."을 쓰는 습관도 도발적으로 받아들여지지만, 이 습관은 유용하다. 한 학생이 문항이 첫 페이지의 맨 밑에서 끝난다는 암묵적인 가정으로 인해 시험에서 거의 낙제했다는 이야기를 들은 적이 있다.) Antony Jay의 이 말이 참 옳다고 느껴진다. "다른 것들과 같이 공동 신앙에서도, 이단자를 추방해야 할 이유는 그가 틀렸을 가능성이 아니라 맞았을 가능성 때문이다."

첫 번째 부분에서는 범위를 표기할 때 하한은 포함하고 상한은 제외해야 되는(이하 "방식 a)") 이유를, 두 번쨰 부분에서는 인덱스가 0부터 시작해야 되는 이유를 설명하고 있습니다. 요즘 들어서는 $$a \le i < b$$ 대신 $$a \le i < a + l$$으로 타협(?)하는 분위기가 보이고 있는데 개인적으로 이 글의 논지에 꽤 공감하는 편입니다.

제목에 C++ 반복자를 써놓고 갑자기 이 글을 인용한 이유는, C++ 반복자가 헷갈리는 이유를 이 글의 내용으로 어느 정도 설명할 수 있기 때문입니다.

* **왜 $$\left[ \mathrm{begin}, \mathrm{end} \right)$$ 범위인가?** - 위 글에서 방식 a)가 가장 합리적임을 설명했다.
* **past-the-end 위치는 왜 있는가?** - `for`문을 돌 때 탈출 조건을 확인하기 편하며, 방식 a)와도 자연스럽게 연결된다.
* **[`std::lower_bound`](https://en.cppreference.com/w/cpp/algorithm/lower_bound)와 [`std::upper_bound`](https://en.cppreference.com/w/cpp/algorithm/upper_bound)의 정의는 도대체 왜 그런가?** - [`std::equal_range`](https://en.cppreference.com/w/cpp/algorithm/equal_range)의 반환값이 $$\left[ \mathrm{begin}, \mathrm{end} \right)$$ 범위가 되도록 하는 정의이다. 그런데 왠지 찜찜하다...?
* **역방향 반복자는 왜 한 칸 뒤를 참조하는가?** - 네????????

완벽하지는 않네요.

이 네 가지 의문점이 제가 STL을 처음 배우면서 가장 헷갈렸던 부분인데, 위 글의 내용과는 별개로 [네이버 블로그](https://blog.naver.com/dlaud5379/221896362168)에 나름대로 이유를 찾아서 올린 적이 있습니다. 이제 이 블로그를 주력으로 사용하고 있으니 해당 글의 내용을 다시 정리해서 올려보려고 합니다.

# 다른 멘탈 모델로 보기

다들 모르는 개념을 배우면서 멘탈 모델을 하나씩은 만드실 거라고 생각합니다. 예를 들어서 제가 반복자를 처음 배울 때의 멘탈 모델 중 하나가 **마인크래프트 핫바**였습니다.

![마인크래프트에서 핫바의 모습. 9개의 사각형이 가로로 붙어 있고 이 중 일부에 아이템이 들어 있다. 선택되어 있는 아이템이 더 크고 밝은 사각형으로 강조되어 있다.](/assets/post-images/minecraft-hotbar.png)

생각해보면 반복자와 핫바로 할 수 있는 것들이 꽤 비슷합니다.

* 읽기 연산 = 아이템 확인
* 쓰기 연산 = 아이템 장착, 사용, 장착 해제...
* 증감 = 마우스 휠
* 임의 접근 = 단축키 1~9

사실 이렇게 의식적으로 생각하면서 멘탈 모델을 정했다기보다는 그동안 마인크래프트를 오래 해와서 친숙하니 반복자를 보자마자 '어 이거 마인크래프트 그거랑 비슷하다'부터 나온 것에 가깝습니다. 여러분도 비슷한 경험이 있는지 모르겠네요.

유감스럽지만, 이 멘탈 모델을 받아들이면 글의 위에서 언급한 "헷갈리는 부분"에 부딪쳐버리게 됩니다.

* "past-the-end 위치라니? 마인크래프트엔 그런 거 없었는데?"
* "정렬 함수를 부르는데 왜 $$\left[ \mathrm{begin}, \mathrm{end} \right)$$ 범위를 받지? past-the-end 어쩌고랑 관련이 있나? 뭐 그렇다고 쳐야지"
* "`value`보다 큰 첫 원소를 가리키는 반복자? 이게 어딜 봐서 상계야"
* "역방향 반복자는 한 칸 앞을 가리킨다고? 아니 또 왜?"

과학에서는 이론의 옳고 그름을 자연 현상을 잘 설명하느냐로 판단합니다. 지동설이 천동설을 밀어낸 것도 천동설에서 주전원과 이심원 같은 걸 도입해야 겨우 설명되는 것을 훨씬 간단히 설명했기 떄문입니다. 이쯤 되면 "마인크래프트 핫바" 멘탈 모델을 **천동설**에 비유해도 무리가 없겠네요.

그러면 마인크래프트 핫바보다 반복자를 더 간단하고 깔끔하게 설명할 수 있는 멘탈 모델이 있을까요? 생각보다 훨씬 가까이 있습니다. **텍스트 커서를 소개합니다.**

![](/assets/post-images/text-cursor.gif)

## 가산 및 감산

텍스트 커서가 반복자랑 무슨 상관일까요? 일단 텍스트 커서로 뭘 할 수 있는지부터 살펴봅시다. 편의상 여기서부터는 "커서"라고만 하면 마우스 커서가 아니라 텍스트 커서를 일컫는 것으로 하겠습니다.

<div data-script='{ "insertable": false, "writable": false, "random": false }'></div>

**바로 위의 이 배열은 인터랙티브입니다!** 클릭하고 좌우 방향키를 눌러보세요. 색상이 살짝 진해졌다면 포커스가 제대로 잡힌 상태입니다.

텍스트 편집을 하려면 어디를 편집하는 것인지 알 수 있어야겠죠. *좌우 방향키로 커서를 움직일 수 있습니다*. 이는 [양방향 반복자](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator)의 증감 연산과 동일합니다.

## 임의 접근

<div data-script='{ "insertable": false, "writable": false }'></div>

한 칸씩만 움직일 수 있으면 지루하겠죠. *마우스로 편집하고 싶은 위치를 누르면 커서가 바로 그 위치로 이동합니다.* 이는 [임의 접근 반복자](https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator)의 덧·뺄셈 연산(특히 `.begin() + x`)과 동일합니다.

## 덮어쓰기

지금은 사라지고 있는 추세지만, 옛날 텍스트 편집기나 워드 프로세서에서는 Insert 키를 눌러서 삽입 모드(Insert)와 수정 모드(Overtype)를 오갈 수 있었습니다.

![수정 모드에서 "stdlib"의 맨 앞에 커서를 두고 "string"으로 편집하고 있다.](/assets/post-images/text-overwrite.gif)

삽입 모드는 우리가 항상 쓰고 있는 익숙한 모드입니다(문자와 문자 사이에 새로운 문자를 삽입함). 수정 모드로 들어가면 커서가 세로선이 아니라 블록 모양으로 반짝이고, 키보드를 치면 **그 칸에 있던 문자가 지워지고 입력한 문자로 바뀝니다**.

<div data-script='{}'></div>

*Insert를 누르고 숫자키 0-9를 눌러서*(키패드 여부는 상관 없습니다) 수정 모드를 체험해볼 수 있습니다. 이는 [출력 반복자](https://en.cppreference.com/w/cpp/named_req/OutputIterator)의 쓰기 연산과 동일합니다(`*it = x;`). 이 상태에서 Insert를 한 번 더 누르면 실제 텍스트 에디터와 동일하게 숫자키를 누르면 커서가 한 칸 오른쪽으로 옮겨갑니다(`*it++ = x;`와 같이 작동합니다).

Insert를 한 번 더 누르면 삽입 모드로 돌아갑니다. C++에서는 보통 배열 중간에 삽입하는 연산을 반복자로 하지 않으므로, 이 모드에서는 글의 주제에 집중하기 위해 입력을 막았습니다.

### 역방향 반복자

그런데 위의 배열에서 Insert를 누르고 자세히 살펴보면 세로선 커서가 있던 곳의 **오른쪽**이 반짝입니다. 커서를 가장 왼쪽에 두면 첫 번째 원소를 수정할 수 있고, 가장 오른쪽(즉, "past-the-end" 위치)에 두면 애초에 수정할 것이 없습니다. 반복자의 동작과 잘 들어맞네요.

수정 모드에서 커서의 오른쪽이 아니라 **왼쪽**이 반짝거리도록 할 수 있다면 역방향 반복자도 어느 정도 설명할 수 있을 것 같습니다. 마침 [**오른쪽에서 왼쪽으로 쓰는 문자 체계**](https://en.wikipedia.org/wiki/Right-to-left_script)가 있네요. 아랍어나 히브리어 등이 여기에 속하는데, 이 언어로도 컴퓨터를 쓸 수 있어야 되기 때문에 텍스트 에디터도 여기에 대응하고 있습니다. 가령...

* 커서가 오른쪽에서 시작하고 글을 쓰면 왼쪽으로 움직인다.
* Home/End 키를 누르면 커서가 가장 왼쪽/오른쪽으로 움직인다.
* 커서에 *방향 표시가 생긴다*. 거짓말 같지만 진짜입니다.
	* 커서가 진행하는 방향으로 가로선이 추가로 그어집니다. LTR(왼쪽에서 오른쪽으로)은 오른쪽, RTL은 왼쪽에 방향 표시가 있습니다.
	* 직접 확인해 보고 싶다면 키보드 배열을 RTL 언어권으로 바꾸거나 파이어폭스에서 about:config를 열고 `bidi.browser.ui`를 `true`로 바꾸면 됩니다.
* 그리고 무엇보다도, **수정 모드에서 커서의 왼쪽이 반짝거린다.**

![커서의 오른쪽 위에 방향 표시가 튀어나와 있다.](/assets/post-images/bidi-cursor.gif)

이런 차이를 알고 나면 역방향 반복자를 만들었을 때 한 칸 앞의 원소를 가리키는 것이 좀 더 납득될지도 모르겠네요. 아래의 배열에서 직접 테스트해볼 수 있습니다(R 키로 방향 전환).

<div data-script='{ "reversible": true }'></div>

## 범위 지정

TODO

<div data-script='{ "selectable": true }'></div>

### 상한과 하한

TODO

<div data-script='{ "selectable": true, "bounds": true }'></div>

[^tn-adjacent-subsequences]: (역자 주) 예를 들어 인접하는 두 수열 2, 3, 4와 5, 6, 7을 a) 방식으로 표기하면 각각 2 &le; i < 5와 5 &le; i < 8이 되고, 전자의 상한(5)이 후자의 하한(5)과 같다.
[^tn-left-exclusive]: (역자 주) 수열 0, 1, 2(0도 자연수로 취급한다)를 b) 방식으로 표기하면 -1 < i &le; 2가 되며, 하한(-1)이 자연수 범위를 벗어난다.
[^tn-right-inclusive]: (역자 주) 0 &le; i &le; -1을 의미한다.