---
layout: post
author: EatChangmyeong
actual_title: "차량기지 알고리즘: The Ultimate Edition"
excerpt: 재미로 구현하는 표현식 파싱 1탄
categories:
- Beta
tags:
- Algorithm
---

**아직 베타 상태인 글입니다!** 사이트 메인에는 안 나오지만 주소를 입력하면 들어올 수 있어요. 이제 진짜로 한 번만 더 검수받고 올려요

----

솔직히 말하자면... 백준에서 [Interpreter](https://www.acmicpc.net/problem/11516)를 풀고 갑자기 뽕이 찼습니다. 간단한 코드를 파싱하고 결과를 출력하는 문제인데, (예외 처리가 없긴 하지만) 플래티넘 1 정도면 나만의 프로그래밍 언어 만드는 거 생각보다 쉽지 않을까 하는 자신감이 붙었거든요!

언젠가는 제가 진짜로 프로그래밍 언어를 하나 만들어서 공개할 수도 있겠지만, 천리길도 한 걸음부터라고 하니 일단은 프로그래밍 언어에서 가장 중요한 요소인 표현식 파싱을 재미로 해 보려고 합니다.

**TL;DR**: 사칙연산, 괄호, 음의 부호까지만 커버하는 알고리즘은 [여기](#규칙-정리-4), [여기 나온 연산자 전부](#진짜마지막-연산자-전부-넣고-다듬기)를 커버하는 알고리즘은 [여기](#차량기지-알고리즘-최종-규칙)를 읽어 주세요.

# 개념 잡기: 중위식과 후위식

표현식은 보통 `foo + bar.baz(a + b) * 7`과 같은 형태로 작성합니다. 이런 "자연스러운" 형태의 식을 **중위식**(*infix notation*)이라고 합니다. 방금 제가 "자연스러운"이라고는 했지만, 계산 순서를 잘 살펴보면 부자연스럽기 짝이 없습니다.

```
foo + bar.baz(a + b) * 7
    5    1   (  2  ) 4
             ~~~3~~~
```

한편, 컴퓨터에게 자연스러운 형태의 식은 따로 있습니다.

```
foo bar .baz a b + f(1) 7 * +
```

*아직 뒤로가기 누르지 말아주세요! 바로 밑에 좀 더 친절한 설명이 있습니다.*

이를 **후위식**(*postfix notation*) 혹은 **역폴란드 표기법**(*reverse Polish notation*)[^fn_polish]이라 합니다. (아래쪽에서 자세히 살펴보겠지만) 제가 설명을 위해 임의로 끼워넣은 기호들이 많고, 식 자체가 복잡하니 더 단순한 `1 * 3 + 5 * 7`로 다시 살펴봅시다.

`1 * 3 + 5 * 7`을 후위식으로 변환한 결과는 `1 3 * 5 7 * +`이고, 왼쪽에서 오른쪽으로 훑으면서 연산자가 나오면 맨 오른쪽의 피연산자 두 개를 꺼내서 연산하는 방식으로 계산할 수 있습니다. 말로만 하면 이해하기 어려울 것 같으니...

1. 식에 등장한 순서대로 `1 3`을 기억하고 있습니다.
	* `1 3`
1. 연산자 `*`가 나왔습니다. 맨 오른쪽의 `1`과 `3`을 곱해서 `3`으로 만듭니다.
	* `3`
1. 식에 등장하는 `5`와 `7`을 추가로 기억합니다.
	* `3 5 7`
1. 연산자 `*`가 나왔습니다. 맨 오른쪽의 `5`와 `7`을 곱해서 `35`로 만듭니다.
	* `3 35`
1. 연산자 `+`가 나왔습니다. 맨 오른쪽의 `3`과 `35`를 더해서 `38`로 만듭니다.
	* `38`
1. 이렇게 얻은 `38`이 후위식의 계산 결과입니다.

후위식은 이렇게 계산 순서가 **일관적으로 왼쪽에서 오른쪽으로**이기 때문에 컴퓨터로 계산하기 편리합니다. 동일한 중위식과 후위식의 연산 순서를 비교하면 다음과 같습니다.

<div class="split">
<div class="split-column">
```
1 * 3 + 5 * 7
  1   3   2
```
</div>
<div class="split-column">
```
1 3 * 5 7 * +
    1     2 3
```
</div>
</div>

똑같은 이유로 후위식에는 *괄호가 아예 필요 없어집니다*. 위에 썼던 `f(1)`은 제가 임의로 끼워넣은 기호니까 아직 신경 쓰지 말아주세요.

그나저나 글을 쓰다 보니까 기호를 많이 쓰게 됐는데, 연산자 다음에 토씨가 오면 은/는, 을/를, 이/가 중에 뭘 쓸지 고민하다가 그냥 "연산자"에 맞춰서 '는', '를', '가', ...로 통일하기로 했습니다.

개념 설명은 얼추 끝난 것 같으니 본론으로 돌아가 봅시다!

# 중위식을 후위식으로

PostScript나 Lisp 같은 언어를 만들 게 아니라면 보통 표현식은 중위식으로 작성하게 됩니다. 아까 보았듯이 중위식은 (컴퓨터 입장에서) *정말* 부자연스러운 식이라서 AST를 만들거나 후위식으로 바꾸게 되는데, AST는 한 번도 안 만들어봤으니 후위식으로 바꿔 보겠습니다.

중위식을 후위식으로 바꾸는 알고리즘에는 [**차량기지 알고리즘**](https://ko.wikipedia.org/wiki/%EC%B0%A8%EB%9F%89%EA%B8%B0%EC%A7%80_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)(*Shunting-yard algorithm*)이라는 이름이 붙어 있다고 합니다. 뭐 구글링할 때 매번 "후위식 변환 알고리즘"이나 "infix to postfix"를 치는 것보다는 이름을 불러주는 게 낫겠지만 재밌는 이름은 아니네요. 이 알고리즘은 학교 친구 공부를 도와주다가 수능특강이나 수능완성에서(정확히는 기억이 안 나네요) 처음 접했는데, 처음에는 원리를 몰라서 그냥 책에 쓰여있는 대로 따라했었다가 지금은 과정을 대충 외울 수 있을 정도로 익혔습니다.

이 시리즈의 목표는... 차량기지 알고리즘만 써서 웬만한 프로그래밍 언어에 나오는 표현식을 전부 파싱할 수 있는 프로그램을 짜는 것입니다(의미 분석까지는 안 할 예정입니다). 물론 진짜 C나 JavaScript 표현식을 파싱하라고 하면 기절하니까 간단한 커스텀 문법을 만들려고 합니다. 원래 글 하나로 마치려고 했는데 쓰다 보니까 글이 엄청나게 길어지고 다른 할 얘기도 생겨서 글 여러 편으로 나누기로 했습니다.

처음부터 알고리즘을 전부 설명하려면 너무 어려울 테니 덧뺄셈부터 시작해서 차근차근 규칙을 늘려 봅시다.

# 기초: 덧셈과 뺄셈

우선 `5 + 8 - x + 7`(토큰화는 이미 완료된 상태라고 가정합시다)을 후위식으로 변환해 봅시다.

| 연산자 | 설명 | 우선순위 | 결합성 |
| - | - | - | - |
| `+` | 덧셈 | 1 | 좌 |
| `-` | 뺄셈 | 1 | 좌 |

이 표에 대해서는 나중에 더 자세히 얘기하겠습니다.

출력으로 사용할 큐와 연산자를 넣을 스택이 하나씩 필요합니다. 입력에서 토큰을 하나씩 빼오면서 스택이나 출력에 넣는 것을 반복하면서 알고리즘을 진행합니다. 물론 스택은 임시로 뭘 넣어 놓는 용도고, 최종적으로는 모든 토큰이 출력으로 빠져나와야 합니다.

1. 초기 상태
	* 입력: `5` `+` `8` `-` `x` `+` `7`
	* 스택: *(비어 있음)*
	* 출력: *(비어 있음)*
1. 피연산자는 그냥 출력으로 뺍니다.
	* 입력: `+` `8` `-` `x` `+` `7`
	* 스택: *(비어 있음)*
	* 출력: **`5`**
1. 연산자는 일단 스택에 넣어놓습니다.
	* 입력: `8` `-` `x` `+` `7`
	* 스택: **`+`**
	* 출력: `5`
1. 피연산자는 무조건 출력으로 뺍니다. 무조건입니다.
	* 입력: `-` `x` `+` `7`
	* 스택: `+`
	* 출력: `5` **`8`**
1. 다음 토큰은 연산자입니다. 여기서부터 고뇌의 순간이 시작됩니다.

`-` 토큰을 스택에 넣어야 할까요, 출력으로 넣어야 할까요? 이미 스택에 있는 `+` 토큰은 어떡할까요?

일단 우리가 원하는 출력을 생각해 봅시다. `5 + 8`을 먼저 계산하고 `- x`를 나중에 계산하므로 결과는 **`5 8 + x -`**가 되어야 합니다(`+ 7`은 나중에 생각합시다). 출력 큐에는 `5` `8`이 들어있으니 스택에 있는 `+`를 큐로 넣으면 되겠군요!

* 입력: `-` `x` `+` `7`
* 스택: *(비어 있음)*
* 출력: `5` `8` **`+`**

물론 다음 토큰을 그대로 놔둘 수는 없으니 일단 스택에 넣어둡시다.

* 입력: `x` `+` `7`
* 스택: **`-`**
* 출력: `5` `8` `+`

## 차량기지 알고리즘의 철칙!

앞으로 연산자가 나올 때마다 매번 이런 의사 결정 과정을 거칠 예정이니, 매번 뭘 넣고 뭘 뺄지 고민하지 않도록 원칙을 하나 정해봅시다.

> **먼저 연산하는 연산자가 더 가볍다.**

위에서 살펴봤듯이 후위식은 아무 생각 없이 왼쪽에서 오른쪽으로 훑기만 해도, 즉 **별도의 연산 순서를 정할 필요 없이** 계산할 수 있는 식입니다. 즉, 연산자의 연산 순서와 후위식에서 그 연산자의 위치는 밀접한 관련이 있습니다.

스택에 여러 연산자가 들어있다면, 스택에서 가장 위에 있는 연산자가 가장 먼저 빠져나가고(LIFO니까요), 후위식에서 가장 왼쪽에 위치합니다(먼저 계산됩니다). 즉, *먼저 계산되는 연산자를 스택에서 위에 놓아야 합니다*. 보통 무언가를 쌓을 때는 무거운 것 위에 가벼운 것을 놓으니 "위에 있는" = "가벼운"이라고 하면 "먼저 연산하는 연산자가 가볍다"가 됩니다. 동시에 두 연산자를 계산하는 일은 없으므로 "무게"가 같은 연산자는 없다고 생각해도 됩니다.

위에서 언급은 안 하고 넘어갔지만, 피연산자는 무조건 출력으로 넣고 연산자는 무조건 스택으로 넣습니다. 연산자를 넣는 과정에서 "무게"에 따라 스택에서 기존의 연산자를 뺄지 말지가 결정됩니다.

알고리즘을 마저 돌려봅시다.

1. 피연산자네요!
	* 입력: `+` `7`
	* 스택: `-`
	* 출력: `5` `8` `+` **`x`**
1. 연산자 의사결정의 시간이 돌아왔습니다.
	* `+`와 `-`는 딱히 우선순위가 없고 왼쪽부터 계산하니 오른쪽 연산자가 무겁습니다. 스택에서 자리를 비켜줍시다.
		* 입력: `+` `7`
		* 스택: *(비어 있음)*
		* 출력: `5` `8` `+` `x` **`-`**
	* 이제 `+`를 스택에 넣습니다.
		* 입력: `7`
		* 스택: **`+`**
		* 출력: `5` `8` `+` `x` `-`
1. 네.
	* 입력: *(비어 있음)*
	* 스택: `+`
	* 출력: `5` `8` `+` `x` `-` **`7`**
1. 입력이 비면 스택에 있는 걸 전부 꺼내서 출력으로 넣습니다.
	* 입력: *(비어 있음)*
	* 스택: *(비어 있음)*
	* 출력: `5` `8` `+` `x` `-` `7` **`+`**
1. 알고리즘이 끝났습니다.
	* 출력: **`5 8 + x - 7 +`**

이 과정을 거치면서 유추할 수 있는 알고리즘의 절차를 간단히 정리하면 이렇습니다.

## 규칙 정리 (1)

1. 피연산자는 그대로 출력으로 빼낸다.
1. 연산자는 스택에 넣는다. 이때 스택에 자신보다 "가벼운", 즉 먼저 연산되는 연산자가 있으면 스택의 끝에 도달할 때까지 모두 출력으로 빼낸다.
	1. 입력에서 먼저 나오는 연산자가 더 가볍다.
1. 입력이 끝나면 스택을 끝까지 비우고 출력으로 빼낸다.

# 우선순위: 곱셈과 나눗셈

물론 연산을 하는데 `*`와 `/`가 빠지면 섭하겠죠. 이왕 넣는 김에 `%`도 넣어봅시다.

| 연산자 | 설명 | 우선순위 | 결합성 |
| - | - | - | - |
| `*` | 곱셈 | 2 | 좌 |
| `/` | 나눗셈 | 2 | 좌 |
| `%` | 나머지 | 2 | 좌 |
| `+` | 덧셈 | 1 | 좌 |
| `-` | 뺄셈 | 1 | 좌 |

우선순위 2인 연산자가 생겼네요! 우선순위가 2인 연산자는 *무조건* 우선순위가 1인 연산자보다 먼저 계산합니다. 이번에는 `y + z * 5`를 입력해 봅시다.

1. 초기 상태
	* 입력: `y` `+` `z` `*` `5`
	* 스택: *(비어 있음)*
	* 출력: *(비어 있음)*
1. (피연산자 출력)
	* 입력: `+` `z` `*` `5`
	* 스택: *(비어 있음)*
	* 출력: **`y`**
1. 아직은 눈에 띄게 바뀐 것이 없습니다. 스택에 넣습니다.
	* 입력: `z` `*` `5`
	* 스택: **`+`**
	* 출력: `y`
1. (피연산자 출력)
	* 입력: `*` `5`
	* 스택: `+`
	* 출력: `y` **`z`**
1. 다시 고뇌의 순간이 찾아왔습니다.

`*`를 어떻게 해야 할까요? 위에서 언급했던 차량기지 알고리즘 철칙을 기억해 봅시다.

> **먼저 연산하는 연산자가 더 가볍다.**

`+`와 `*`는 우선순위 차이가 있으므로 `*`가 무조건 먼저이며 `+`보다 가볍습니다. 그냥 스택에 넣어도 되겠네요!

* 입력: `5`
* 스택: `+` **`*`**
* 출력: `y` `z`

1. (피연산자 출력)
	* 입력: *(비어 있음)*
	* 스택: `+` `*`
	* 출력: `y` `z` **`5`**
1. 스택을 맨 위에서부터 차례대로 비웁니다.
	* 입력: *(비어 있음)*
	* 스택: *(비어 있음)*
	* 출력: `y` `z` `5` **`*`** **`+`**
1. 알고리즘이 끝났습니다.
	* 출력: **`y z 5 * +`**

위에서 정리한 규칙에도 무언가를 추가해야 할 것 같습니다. 다시 살펴봅시다.

## 규칙 정리 (2)

1. 피연산자는 그대로 출력으로 빼낸다.
1. 연산자는 스택에 넣는다. 이때 스택에 자신보다 "가벼운", 즉 먼저 연산되는 연산자가 있으면 스택의 끝에 도달할 때까지 모두 출력으로 빼낸다.
	1. **우선순위가 높을수록 더 가볍다.** (New!)
	1. 우선순위가 같으면 입력에서 먼저 나오는 연산자가 더 가볍다.
1. 입력이 끝나면 스택을 끝까지 비우고 출력으로 빼낸다.

# 결합성: 거듭제곱

아직 연산자 표에서 설명을 안 했던 결합성에 대해 이야기할 차례입니다.

JavaScript(ES2016)와 Python 등에서는 `**` 연산자를 거듭제곱으로 씁니다. 일상생활에서는 `^` 기호를 거듭제곱처럼 쓰지만 그거는 이미 웬만한 프로그래밍 언어에서 XOR 연산자로 쓰니 여기서도 `**`를 쓰겠습니다.

거듭제곱은 좌결합성을 띠는 다른 연산과 달리 **우결합성**을 띱니다. 이게 무슨 소리냐면,

$$a + b + c + d = ((a + b) + c) + d$$

이지만

$$a \verb!^! b \verb!^! c \verb!^! d = a \verb!^! (b \verb!^! (c \verb!^! d))$$

라는 의미입니다. 오른쪽을 먼저 계산합니다.

| 연산자 | 설명 | 우선순위 | 결합성 |
| - | - | - | - |
| `**` | 거듭제곱 | 3 | 우 |
| `*` | 곱셈 | 2 | 좌 |
| `/` | 나눗셈 | 2 | 좌 |
| `%` | 나머지 | 2 | 좌 |
| `+` | 덧셈 | 1 | 좌 |
| `-` | 뺄셈 | 1 | 좌 |

이번에는 `5 + 5 ** 5 ** 5 / 5`를 입력해 봅시다.

1. 초기 상태
	* 입력: `5` `+` `5` `**` `5` `**` `5` `/` `5`
	* 스택: *(비어 있음)*
	* 출력: *(비어 있음)*
1. 과정 쓰는 게 조금씩 귀찮아지니 세 단계를 한꺼번에 진행하겠습니다.
	* 입력: `**` `5` `**` `5` `/` `5`
	* 스택: `+`
	* 출력: `5` `5`
1. 규칙 2-1에 의해 `**`를 그대로 스택에 올려놓습니다.
	* 입력: `5` `**` `5` `/` `5`
	* 스택: `+` **`**`**
	* 출력: `5` `5`
1. (피연산자 출력)
	* 입력: `**` `5` `/` `5`
	* 스택: `+` `**`
	* 출력: `5` `5` **`5`**
1. 고뇌의 순간!

좌결합성만 염두에 두고 설계한 규칙에 우결합성 연산자를 넣으면 터질 것이 분명합니다. 다시 차량기지 알고리즘의 철칙을 생각해보면, 첫 번째 `**`를 두 번째 `**`보다 나중에 계산하므로 더 무겁습니다. 그러니 아무것도 빼지 않고 그대로 스택에 넣어봅시다!

* 입력: `5` `/` `5`
* 스택: `+` `**` **`**`**
* 출력: `5` `5` `5`

1. 계속해봅시다. 다음 토큰이 피연산자니 출력에 넣습니다.
	* 입력: `/` `5`
	* 스택: `+` `**` `**`
	* 출력: `5` `5` `5` **`5`**
1. `/`는 스택에 있는 `**` 두 개보다 무거우므로 규칙 2에 의해 모두 빼고 나서 넣습니다.
	* 입력: `5`
	* 스택: `+` **`/`**
	* 출력: `5` `5` `5` `5` **`**`** **`**`**
1. (피연산자 출력)
	* 입력: *(비어 있음)*
	* 스택: `+` `/`
	* 출력: `5` `5` `5` `5` `**` `**` **`5`**
1. 규칙 3을 따라 스택을 모두 비웁니다.
	* 입력: *(비어 있음)*
	* 스택: *(비어 있음)*
	* 출력: `5` `5` `5` `5` `**` `**` `5` **`/`** **`+`**
1. 알고리즘이 끝났습니다.
	* 출력: **`5 5 5 5 ** ** 5 / +`**

위에서 살펴본 우결합성 규칙을 반영해 봅시다.

## 규칙 정리 (3)

1. 피연산자는 그대로 출력으로 빼낸다.
1. 연산자는 스택에 넣는다. 이때 스택에 자신보다 "가벼운", 즉 먼저 연산되는 연산자가 있으면 스택의 끝에 도달할 때까지 모두 출력으로 빼낸다.
	1. 우선순위가 높을수록 더 가볍다.
	1. 우선순위가 같으면 아래와 같이 처리한다.
		1. 좌결합성이면 입력에서 먼저 나오는 연산자가 더 가볍다.
		1. **우결합성이면 입력에서 나중에 나오는 연산자가 더 가볍다.** (New!)
1. 입력이 끝나면 스택을 끝까지 비우고 출력으로 빼낸다.

# 괄호 처리

표현식에 괄호가 빠지면 섭섭하죠. 연산자 표에 괄호를 추가해 봅시다.

| 연산자 | 설명 | 우선순위 | 결합성 |
| - | - | - | - |
| `(`~`)` | 괄호 | ∞ | - |
| `**` | 거듭제곱 | 3 | 우 |
| `*` | 곱셈 | 2 | 좌 |
| `/` | 나눗셈 | 2 | 좌 |
| `%` | 나머지 | 2 | 좌 |
| `+` | 덧셈 | 1 | 좌 |
| `-` | 뺄셈 | 1 | 좌 |

그런데 괄호는 지금까지 봤던 연산자와는... 꽤나 달라 보입니다. 애초에 괄호의 역할은 피연산자를 받아서 연산하는 것이 아니라 우선순위를 표시하는 것입니다. 이 알고리즘에서는 괄호를 도대체 어떻게 처리해야 할까요?

## 괄호 처리의 철칙!

> **괄호 안의 표현식은 완결되어 있다.**

다르게 얘기해서, 괄호 안쪽만 분리했는데 갑자기 잘못된 표현식이 되는 일은 없습니다. 얼핏 당연해 보이는 이야기지만, 이 성질을 이용해서 괄호를 만나면 괄호 안쪽만 재귀적으로 차량기지 알고리즘을 돌리고 결과에 갖다붙이는 방법을 생각해볼 수 있습니다.

* `p + (괄호 안쪽 중위식...) + q` → `p (괄호 안쪽 후위식...) + q +`

물론 이렇게 하면 입출력 큐와 스택을 여러 개씩 써야 하는 문제점이 있습니다. 그런데 좀 더 생각해보면 굳이 큐/스택을 여러 개 만들 필요도 없습니다.

우선 완결된 표현식은 스택을 있는 만큼만 쓰고 더 쓰지 않으니(지금까지 알고리즘을 돌리면서 스택 바닥을 뚫은 적이 있었나요?), 원래 있던 스택의 맨 위 부분을 잘라서 "새로운 스택"이라고 해도 전혀 문제가 생기지 않습니다.

또한, 완결된 표현식은 큐에 출력했을 때 한 덩어리가 됩니다. 애초에 출력으로 쓰는 큐가 하나밖에 없으니 한 덩어리가 될 수밖에 없죠. 역시 원래 있던 큐의 한 부분을 잘라서 "새로운 큐"라고 해도(즉, "아무 생각 안 하고 그냥 출력해도") 전혀 문제가 생기지 않습니다.

이 성질을 이용하면 괄호에 약간의 특수 처리를 추가해서 재귀 없는 차량기지 알고리즘을 짤 수 있습니다. 스택 한 뭉치를 잘라주는 방법이 있어야 되는데, 여는 괄호 `(`를 스택 경계로 활용할 수 있겠네요.

이번에는 `a * (b + c) * d`로 해 봅시다.

1. 초기 상태
	* 입력: `a` `*` `(` `b` `+` `c` `)` `*` `d`
	* 스택: *(비어 있음)*
	* 출력: *(비어 있음)*
1. (두 단계 진행)
	* 입력: `(` `b` `+` `c` `)` `*` `d`
	* 스택: **`*`**
	* 출력: **`a`**
1. 대망의 괄호입니다! 안쪽 표현식임을 표시하기 위해 스택에 `(`를 넣어둡시다. 별도의 스택을 만들지 않은 점에 유의합니다.
	* 입력: `b` `+` `c` `)` `*` `d`
	* 스택: `*` **`(`**
	* 출력: `a`
1. (세 단계 진행)
	* 입력: `)` `*` `d`
	* 스택: `*` `(` **`+`**
	* 출력: `a` **`b`** **`c`**
1. 괄호 안쪽 식이 끝났습니다!
	* 원래 차량기지 알고리즘에서 그랬듯이 스택에서 `(`가 나오기 직전까지 전부 비웁니다.
		* 입력: `)` `*` `d`
		* 스택: `*` `(`
		* 출력: `a` `b` `c` **`+`**
	* 이제 괄호 한 쌍을 전부 없앱니다. 후위식에는 괄호가 필요 없으니까요!
		* 입력: `*` `d`
		* 스택: `*`
		* 출력: `a` `b` `c` `+`
1. 알고리즘을 원래대로 계속 진행합니다.
	* 입력: *(비어 있음)*
	* 스택: *(비어 있음)*
	* 출력: `a` `b` `c` `+` **`*`** **`d`** **`*`**
1. 알고리즘이 끝났습니다.
	* 출력: **`a b c + * d *`**

규칙 정리의 시간이 돌아왔습니다.

## 규칙 정리 (4)

1. 피연산자는 그대로 출력으로 빼낸다.
1. **여는 괄호는 스택의 끝처럼 취급한다.** 아래에서 `스택의 끝`이라고 할 때는 무조건 실제 스택의 끝 *혹은* 여는 괄호의 의미로 해석한다. (New!)
1. **닫는 괄호는 입력의 끝처럼 취급한다.** 아래에서 `입력의 끝`이라고 할 때는 무조건 실제 입력의 끝 *혹은* 닫는 괄호의 의미로 해석한다. (New!)
1. 연산자는 스택에 넣는다. 이때 스택에 자신보다 "가벼운", 즉 먼저 연산되는 연산자가 있으면 `스택의 끝`에 도달할 때까지 모두 출력으로 빼낸다.
	1. 우선순위가 높을수록 더 가볍다.
	1. 우선순위가 같으면 아래와 같이 처리한다.
		1. 좌결합성이면 입력에서 먼저 나오는 연산자가 더 가볍다.
		1. 우결합성이면 입력에서 나중에 나오는 연산자가 더 가볍다.
1. 입력이 `끝나면` 스택을 `끝까지` 비우고 출력으로 빼낸다. 그런 뒤...
	1. **그 `입력의 끝`이 일반 닫는 괄호(`)`)일 경우에는 해당되는 괄호 쌍을 모두 없앤다.** (New!)

읽으면서 헷갈릴 수 있으니 `스택의 끝`과 `입력의 끝`은 전부 별도로 표시했습니다. 이 정도의 규칙만 있어도 (프로그래밍 맥락이 아닌) 웬만한 중위 표현식은 전부 파싱할 수 있습니다.

# 전위 단항 연산자: 음수는 어떡하지?

사실 부호가 붙은 숫자열 전체를 토큰으로 만들기는 좀 부담스러운 면이 있습니다. 위에서까지는 그냥 문자열을 훑다가 적당한 곳에서 잘라주기만 하면 됐는데, 음수도 리터럴로 취급하면 `-123`과 `5-123`은 어떡하죠? `-` `123`? `-123`? `5` `-` `123`? `5` `-123`?

그래서 보통은 음의 부호 `-`를 별도의 단항 연산자로 취급하고 별도의 토큰으로 자르는 방식을 선호합니다. 물론 이대로라면 이항 빼기 연산자 `-`와 구분할 수 없으니 이 글에서는 단항 음의 부호를 `u-`(unary `-`)로 표기하도록 하겠습니다.

이왕 넣는 김에 단항 양의 부호 `u+`와 전위 증감 연산자 `pre++`/`pre--`(prefix `++`/`--`)도 넣어봅시다. 왜 굳이 pre를 붙였냐면 나중에 후위 증감 연산자도 추가할 거라서 그렇습니다. 여기서부터 입력되는 표기가 내부 처리용 표기와 다른 연산자가 더 생길 텐데, 어차피 이 글에서는 토큰화가 다 되어있음을 가정하고 있으니 연산자 표에는 후자만 넣겠습니다.

전위 연산자의 결합성은 아무래도 우결합성이 좋겠습니다. 애초에 좌결합성이면 괄호를 붙일 수가 없거든요. 또 우선순위는 괄호보다는 당연히 낮고, 다른 사칙연산 연산자보다는 높은 게 적당하겠습니다. 우선순위 때문에 `-x` 같은 게 중간에서 깨지면 안 되잖아요.

| 연산자 | 설명 | 우선순위 | 결합성 |
| - | - | - | - | - |
| `(`~`)` | 괄호 | - | - |
| `u+` | 양의 부호 | 4 | 우 |
| `u-` | 음의 부호 | 4 | 우 |
| `pre++` | 전위 증가 | 4 | 우 |
| `pre--` | 전위 감소 | 4 | 우 |
| `**` | 거듭제곱 | 3 | 우 |
| `*` | 곱셈 | 2 | 좌 |
| `/` | 나눗셈 | 2 | 좌 |
| `%` | 나머지 | 2 | 좌 |
| `+` | 덧셈 | 1 | 좌 |
| `-` | 뺄셈 | 1 | 좌 |

아까 괄호를 "우선순위를 표기하는 연산자"라고 했었는데, 괄호 자체에 우선순위를 부여하면 좀 앞뒤가 안 맞는 것 같아서 지웠습니다.

이번에는 `y + -(++x)`를 돌려봅시다.

1. 초기 상태
	* 입력: `y` `+` `u-` `(` `pre++` `x` `)`
	* 스택: *(비어 있음)*
	* 출력: *(비어 있음)*
1. (두 단계 진행)
	* 입력: `u-` `(` `pre++` `x` `)`
	* 스택: **`+`**
	* 출력: **`y`**
1. 고뇌의 순간!

지금까지 차량기지 알고리즘에서 처리했던 연산자는 전부 이항이었습니다. 단항 연산자는 어떻게 처리해야 될까요?

단항 음의 부호 `-x` 앞에 사실 0이 있어서 `0 - x`처럼 취급할 수 있다고 해 봅시다. 이를 후위식으로 변환하면 `0 x u-`(여기까지 읽었으면 이 정도는 설명 없이 변환해도 괜찮겠죠?)이 되고, 유령 `0`을 지우면 `x u-`가 됩니다.

아직은 어떻게 처리할지 잘 모르겠으니 `u-`가 더 많이 붙은 `---x`를 변환해 봅시다. 유령 `0`을 붙이면 `0 -ㄱ (0 -ㄴ (0 -ㄷ x))`가 되고(구별을 위해 여기서만 `ㄱ`, `ㄴ`, `ㄷ`을 붙이겠습니다), 후위식으로 변환하면 `0 0 0 x u-ㄷ u-ㄴ u-ㄱ`가 됩니다. 유령 `0`을 모두 지우면 `x u-ㄷ u-ㄴ u-ㄱ`가 됩니다. 잠깐, 저 괄호 배치 어디서 많이 본 것 같지 않나요?

위에서 단항 음의 부호 `u-`를 처리한 결과는 `u-`를 위에서 언급한 우선순위의 우결합성 연산자로 설정하고 아무 생각 없이 알고리즘을 돌린 결과와 *같습니다*. 이 연산자가 좌결합성이었다면 `((0 -ㄱ 0) -ㄴ 0) -ㄷ x` → `0 0 u-ㄱ 0 u-ㄴ x u-ㄷ` → `u-ㄱ u-ㄴ x u-ㄷ`와 같은 잘못된 결과가 나오고, 우선순위가 더 낮았다면 다른 이항 연산자와 섞여서 처리가 꼬였을 것입니다. 차량기지 알고리즘에 전위 단항 연산자를 넣으려면 *반드시 이 우선순위, 이 결합성이어야 합니다*.

문단이 길어졌네요. 아무튼 아무 생각 없이 그대로 돌려도 괜찮다는 결론을 얻었으니 계속해 봅시다.

1. 규칙 4-1을 따라 아무것도 하지 않고 스택에 넣습니다.
	* 입력: `(` `pre++` `x` `)`
	* 스택: `+` **`u-`**
	* 출력: `y`
1. 역시 규칙 4-1을 따라 여는 괄호(aka `스택의 끝`)를 스택에 넣습니다.
	* 입력: `pre++` `x` `)`
	* 스택: `+` `u-` **`(`**
	* 출력: `y`
1. `pre++`는 괄호보다 우선순위가 낮지만 여는 괄호는 `스택의 끝`이므로 그냥 스택에 넣습니다.
	* 입력: `x` `)`
	* 스택: `+` `u-` `(` **`pre++`**
	* 출력: `y`
1. (피연산자 출력)
	* 입력: `)`
	* 스택: `+` `u-` `(` `pre++`
	* 출력: `y` **`x`**
1. 닫는 괄호(aka `입력의 끝`)가 나왔습니다.
	* 스택을 `끝까지` 비웁니다.
		* 입력: `)`
		* 스택: `+` `u-` `(`
		* 출력: `y` `x` **`pre++`**
	* 남은 괄호 쌍은 규칙 5에 의해 없앱니다.
		* 입력: *(비어 있음)*
		* 스택: `+` `u-`
		* 출력: `y` `x` `pre++`
1. 이번에는 진짜 `입력의 끝`이므로 스택을 `끝까지` 비웁니다.
	* 입력: *(비어 있음)*
	* 스택: *(비어 있음)*
	* 출력: `y` `x` `pre++` **`u-`** **`+`**
1. 알고리즘이 끝났습니다.
	* 출력: **`y x pre++ u- +`**

이번에는 딱히 규칙을 업데이트할 필요는 없을 것 같네요!

# 멀티파트: 삼항 분기 연산자

프로그래밍 언어를 짤 때 필수는 아니지만, 삼항 분기 연산자 `?:`도 있으면 좋을 것 같습니다.

다들 한 번씩은 써보셨겠지만, `a ? b : c`라고 써두면 `a`가 참이면 `b`, 거짓이면 `c`로 평가되는 연산자로, 의사코드 `if(a) b; else c;`와 같은 의미를 가집니다. 여러 프로그래밍 언어에서 *유일한* 삼항 연산자의 위치를 차지하고, 보통 그냥 "삼항 연산자"라고 하면 이 연산자를 얘기하는 경우가 많습니다. 그렇지만 [곱셈 누산 연산](https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation)이나 SQL의 [BETWEEN 연산자](https://en.wikipedia.org/wiki/SQL_syntax#Operators) 등 `?:`가 아닌 삼항 연산자도 엄연히 존재하기 때문에(프로그래밍 분야 바깥으로 확장한다면 더더욱) `?:`를 그냥 "삼항 연산자"라고 부르는 것을 개인적으로 싫어하는 편입니다. "(삼항) 조건 연산자", "삼항 조건문" 등의 대체어가 있는데, 이 글에서는 "삼항 분기 연산자"라고 하겠습니다. 거창한 이유가 있는 건 아니고 "조건"보다 "분기"가 더 적합할 것 같아서 이 단어를 골랐습니다.

다른 연산자처럼 우선순위와 결합성을 먼저 고민해 봅시다. 결합성이 의미가 있긴 한 건가 할 수 있을 텐데, `a ? b ? c : d : e` 같은 경우는 몰라도 `a ? b : c ? d : e`라면 고민해볼 수 있습니다. `(a ? b : c) ? d : e`와 `a ? b : (c ? d : e)` 중 어느 쪽으로 정할까요? 보통 조건문을 만들 때 `if-else if-else` 구조에 익숙해져 있고 후자가 그 구조를 따르고 있으니 우결합성으로 정합시다. 또 다른 것도 아니고 `if-else`문을 연산자로 만들어버린 것이니 우선순위는 가장 낮게 잡는 것이 좋을 것 같습니다. `?:` 연산자가 `+`나 `-` 같은 연산자 때문에 잘리면 당황스럽겠죠?

| 연산자 | 설명 | 우선순위 | 결합성 |
| - | - | - | - |
| `(`~`)` | 괄호 | - | - |
| `u+` | 양의 부호 | 5 | 우 |
| `u-` | 음의 부호 | 5 | 우 |
| `pre++` | 전위 증가 | 5 | 우 |
| `pre--` | 전위 감소 | 5 | 우 |
| `**` | 거듭제곱 | 4 | 우 |
| `*` | 곱셈 | 3 | 좌 |
| `/` | 나눗셈 | 3 | 좌 |
| `%` | 나머지 | 3 | 좌 |
| `+` | 덧셈 | 2 | 좌 |
| `-` | 뺄셈 | 2 | 좌 |
| `?`~`:` | 삼항 분기 | 1 | 우 |

삼항 분기 연산자는 괄호를 제외하고 처음으로 나오는 멀티파트 연산자, 즉 **여러 부분으로 이루어진** 연산자입니다. 단어 선택을 할 때 영어인 "멀티파트"는 최대한 피하려고 했지만 적당한 단어가 생각이 안 나서 이렇게 적은 점 양해 부탁드립니다. 이 글에서는 괄호와 멀티파트 연산자의 명확한 구분을 위해 삼항 분기 연산자를 *괄호가 아닌* 것으로 봅니다[^fn_parentheses_vs_multipart].

이런 멀티파트 연산자는 연산자의 "어느 부분"까지 왔나 체크하는 게 중요할 것입니다. `a ? b + c : d`을 변환하면서 어떻게 처리할지 확인해 봅시다.

1. 초기 상태
	* 입력: `a` `?` `b` `+` `c` `:` `d`
	* 스택: *(비어 있음)*
	* 출력: *(비어 있음)*
1. (피연산자 출력)
	* 입력: `?` `b` `+` `c` `:` `d`
	* 스택: *(비어 있음)*
	* 출력: **`a`**
1. 스택에 `?`를 넣습니다. 이제 삼항 분기 연산자의 "참" 부분으로 들어왔습니다.
	* 입력: `b` `+` `c` `:` `d`
	* 스택: **`?`**
	* 출력: `a`
1. (세 단계 진행)
	* 입력: `:` `d`
	* 스택: `?` **`+`**
	* 출력: `a` **`b`** **`c`**
1. 스택에 `:`를 넣습니다. 여기부터는 삼항 분기 연산자의 "거짓" 부분입니다.
	* `?`와 `:` 모두 우선순위가 1인 별개의 연산자로 취급하고 스택에 있는 나머지 연산자를 전부 뺍니다.
		* 입력: `d`
		* 스택: `?` **`:`**
		* 출력: `a` `b` `c` **`+`**
	* 애초에 `?`와 `:`는 한 덩어리였는데 스택에서 별개의 토큰으로 취급하려니 귀찮습니다. 하나로 합쳐 놓읍시다.
		* 입력: `d`
		* 스택: **`?:`**
		* 출력: `a` `b` `c` `+`
1. (피연산자 출력)
	* 입력: *(비어 있음)*
	* 스택: **`?:`**
	* 출력: `a` `b` `c` `+` **`d`**
1. 스택을 `끝까지` 비웁니다.
	* 입력: *(비어 있음)*
	* 스택: *(비어 있음)*
	* 출력: `a` `b` `c` `+` `d` **`?:`**
1. 알고리즘이 끝났습니다.
	* 출력: `a b c + d ?:`

두 토큰이 하나로 *합쳐졌습니다*. 스택에 `?`만 있으면 "참" 부분, `?:`가 모두 있으면 "거짓" 부분, 없으면 연산자 밖으로 나온 것이라고 생각할 수 있겠습니다. 이 규칙도 정리해 봅시다. 아차, 그 전에 `?:`도 어차피 스택에서 처리하는 토큰이니 우선순위 정리에 포함해야겠네요.

| 연산자 | 설명 | 우선순위 | 결합성 |
| - | - | - | - |
| `(`~`)` | 괄호 | - | - |
| `u+` | 양의 부호 | 5 | 우 |
| `u-` | 음의 부호 | 5 | 우 |
| `pre++` | 전위 증가 | 5 | 우 |
| `pre--` | 전위 감소 | 5 | 우 |
| `**` | 거듭제곱 | 4 | 우 |
| `*` | 곱셈 | 3 | 좌 |
| `/` | 나눗셈 | 3 | 좌 |
| `%` | 나머지 | 3 | 좌 |
| `+` | 덧셈 | 2 | 좌 |
| `-` | 뺄셈 | 2 | 좌 |
| `?`~`:`, **`?:`** | 삼항 분기 | 1 | 우 |

## 규칙 정리 (5)

1. 피연산자는 그대로 출력으로 빼낸다.
1. 여는 괄호는 스택의 끝처럼 취급한다. 아래에서 `스택의 끝`이라고 할 때는 무조건 실제 스택의 끝 *혹은* 여는 괄호의 의미로 해석한다.
1. 닫는 괄호는 입력의 끝처럼 취급한다. 아래에서 `입력의 끝`이라고 할 때는 무조건 실제 입력의 끝 *혹은* 닫는 괄호의 의미로 해석한다.
1. 연산자는 스택에 넣는다. 그 전에... (수정)
	1. 스택에 자신보다 "가벼운", 즉 먼저 연산되는 연산자가 있으면 `스택의 끝`에 도달하거나 그 연산자와 합칠 수 있을 때까지 모두 출력으로 빼낸다.
		1. 우선순위가 높을수록 더 가볍다.
		1. 우선순위가 같으면 아래와 같이 처리한다.
			1. 좌결합성이면 입력에서 먼저 나오는 연산자가 더 가볍다.
			1. 우결합성이면 입력에서 나중에 나오는 연산자가 더 가볍다.
	1. **스택의 꼭대기에 있는 연산자와 합칠 수 있는 경우 합친다.** (New!)
		1. `?`와 `:`는 `?:`로 합쳐진다.
1. 입력이 `끝나면` 스택을 `끝까지` 비우고 출력으로 빼낸다. 그런 뒤...
	1. 그 `입력의 끝`이 일반 닫는 괄호(`)`)일 경우에는 해당되는 괄호 쌍을 모두 없앤다.

# 후위 연산자

후위 연산자는 꽤 다양한 종류가 있습니다. 좁은 의미로는 후위 증감 연산자만 후위 연산자겠지만, 넓게 보면 이런 것도 후위 연산자로 생각할 수 있습니다.

* 멤버 접근 연산자 `.<identifier>`
* 배열 원소 접근 연산자 `[]`
* 함수 호출 연산자 `()`

가장 간단한 후위 증감 연산자부터 차근차근 따라가 봅시다.

## 기본: 후위 증감 연산자

중간에 삼항 분기 연산자 얘기를 갑자기 하긴 했지만, 전위 증감 연산자가 있으면 후위 증감 연산자도 있어야죠. 각각 `post++`, `post--`로 표현하겠습니다.

후위 증감 연산자의 결합성은 아까 전위 연산자 얘기를 시작할 때 언급했던 이유로 좌결합성으로, 우선순위는 전위 단항 연산자보다 높게 정하겠습니다. 우선순위를 저렇게 잡은 건 알고리즘적인 문제라기보다는 다른 이유인데, 보통 `-foo()`라는 표현식을 쓰면(함수 호출도 일종의 후위 연산자라고 얘기했었죠?) `-(foo())`로 해석하는 것이 자연스럽지만, 우선순위가 전위 단항 연산자보다 낮다면 이 식이 `(-foo)()`로 해석되는 당황스러운 결과가 발생할 수 있습니다...

웬만한 언어의 연산자 우선순위(예를 들어서 [C++](https://en.cppreference.com/w/cpp/language/operator_precedence), [자바스크립트](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/%EC%97%B0%EC%82%B0%EC%9E%90_%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84#%ED%91%9C), [파이썬](https://docs.python.org/3/reference/expressions.html#operator-precedence)은 표 순서가 반대네요)를 살펴보면 대체로 우선순위가 괄호-후위 연산자-전위 연산자이고 후위 연산자는 좌결합성, 전위 연산자는 우결합성을 띠는데, 아마 여기서 살펴본 이유가 크게 작용하지 않았을까 하는 생각입니다~~뇌피셜~~. 잠깐 무관한 얘기를 하자면 대학교 프로그래밍 강의에서 `*a++` 같은 식으로 포인터와 증감 연산자를 꼬아놓는 경우가 있는데, 무조건 후위 연산자가 먼저라고 외워두면 좋습니다.

| 연산자 | 설명 | 우선순위 | 결합성 |
| - | - | - | - | - |
| `(`~`)` | 괄호 | - | - |
| `post++` | 후위 증가 | 6 | 좌 |
| `post--` | 후위 감소 | 6 | 좌 |
| `u+` | 양의 부호 | 5 | 우 |
| `u-` | 음의 부호 | 5 | 우 |
| `pre++` | 전위 증가 | 5 | 우 |
| `pre--` | 전위 감소 | 5 | 우 |
| `**` | 거듭제곱 | 4 | 우 |
| `*` | 곱셈 | 3 | 좌 |
| `/` | 나눗셈 | 3 | 좌 |
| `%` | 나머지 | 3 | 좌 |
| `+` | 덧셈 | 2 | 좌 |
| `-` | 뺄셈 | 2 | 좌 |
| `?`~`:`, `?:` | 삼항 분기 | 1 | 우 |

`a++ + ++a`를 돌려봅시다. C/C++ 프로그래머가 읽으면 뒤집어지겠지만 이게 알고리즘 동작을 확인하는 데는 제일 적당하네요.

1. 초기 상태
	* 입력: `a` `post++` `+` `pre++` `a`
	* 스택: *(비어 있음)*
	* 출력: *(비어 있음)*
1. (두 단계 진행)
	* 입력: `+` `pre++` `a`
	* 스택: **`post++`**
	* 출력: **`a`**
1. 규칙 4-1-1을 따라 `post++`를 꺼냅니다.
	* 입력: `pre++` `a`
	* 스택: **`+`**
	* 출력: `a` **`post++`**
1. 역시 규칙 4-1-1을 따라 `pre++`는 그냥 스택에 넣습니다.
	* 입력: `a`
	* 스택: `+` **`pre++`**
	* 출력: `a` `post++`
1. (피연산자 출력)
	* 입력: *(비어 있음)*
	* 스택: `+` `pre++`
	* 출력: `a` `post++` **`a`**
1. 스택을 `끝까지` 비웁니다.
	* 입력: *(비어 있음)*
	* 스택: *(비어 있음)*
	* 출력: `a` `post++` `a` **`pre++`** **`+`**
1. 알고리즘이 끝났습니다.
	* 출력: **`a post++ a pre++ +`**

## 심화: 배열과 함수 호출

위에서 멤버 접근 연산자 `.<identifier>`, 함수 호출 연산자 `()`, 배열 원소 접근 연산자 `[]`도 일종의 후위 단항 연산자라고 했습니다. 이 세 연산자는 알고리즘에 어떻게 반영하면 좋을까요?

### 멤버 접근 연산자

일단 기존의 이항 연산자와 가장 비슷해 보이는 멤버 접근 연산자 `.<identifier>`부터 생각해 봅시다.

`a.b`는 단항 연산자처럼 `a` `.b`로 만들 수도 있고, 이항 연산자처럼 `a` `b` `.`로 만들 수도 있습니다.
* 전자는 파싱 단계에서 별도의 처리를 할 필요가 없습니다.
	* 함수 호출 연산자, 배열 원소 접근 연산자와 달리 `b`에 임의의 표현식이 아니라 식별자 하나만 와야 합니다.
	* "우변"의 식별자를 변수명으로 취급하지 않도록 주의해야 합니다.
* 후자는 이항처럼 보이는 연산자로서 다른 연산자와 일관적인 규칙을 가지며, 토큰화 단계에서 별도의 처리를 할 필요가 없습니다.

이렇게 적어보기 전에는 "그냥 이항으로 취급할까???" 했는데, 어차피 `.` `b`는 토큰화 과정에서 쉽게 합칠 수 있을 것 같으므로 단항 연산자로 취급하기로 했습니다.

**멤버 접근 연산자는 후위 증감 연산자와 같은 우선순위이고 좌결합성을 띠는 연산자로 정합니다.** 차량기지 알고리즘에 넣으면 후위 증감 연산자와 완전히 동일하게 처리될 것이므로 예시는 생략합니다.

### 배열 원소 접근 연산자

남은 두 연산자 중에 상대적으로 간단한(기존의 기호와 겹치지 않고, 안쪽에 단 하나의 표현식이 들어가는) 배열 원소 접근 연산자 `[]`는 어떻게 할까요?

이 연산자는 *괄호와 후위 연산자의 성질을 모두 띱니다*. 이미 규칙으로 정리한 괄호 `()`의 성질을 그대로 적용하되, 닫힐 때 그냥 없애는 대신 다른 처리를 하면 될 것 같습니다. `foo[5 * (4 + 3)]`을 돌리면서 생각해 봅시다.

1. 초기 상태
	* 입력: `foo` `[` `5` `*` `(` `4` `+` `3` `)` `]`
	* 스택: *(비어 있음)*
	* 출력: *(비어 있음)*
1. (피연산자 출력)
	* 입력: `[` `5` `*` `(` `4` `+` `3` `)` `]`
	* 스택: *(비어 있음)*
	* 출력: **`foo`**
1. 대괄호를 스택에 넣습니다. 이것도 소괄호처럼 `스택의 끝`으로 취급할 예정입니다.
	* 입력: `5` `*` `(` `4` `+` `3` `)` `]`
	* 스택: **`[`**
	* 출력: `foo`
1. (무려 여섯 단계나 진행!!!)
	* 입력: `)` `]`
	* 스택: `[` **`*`** **`(`** **`+`**
	* 출력: `foo` **`5`** **`4`** **`3`**
1. 규칙 5를 따라 안쪽 괄호를 닫습니다.
	* 입력: `]`
	* 스택: `[` `*`
	* 출력: `foo` `5` `4` `3` **`+`**
1. 대괄호를 닫습니다!
	* 일단 규칙 5를 따라 스택을 `끝까지` 비웁니다.
		* 입력: `]`
		* 스택: `[`
		* 출력: `foo` `5` `4` `3` `+` **`*`**
	* 배열 원소에 접근함을 어떻게든 표시해야 합니다. 대괄호를 그대로 지우는 대신 출력으로 넣어 봅시다.
		* 입력: *(비어 있음)*
		* 스택: *(비어 있음)*
		* 출력: `foo` `5` `4` `3` `+` `*` **`[]`**
1. 알고리즘이 끝났습니다.
	* 출력: **`foo 5 4 3 + * []`**

마지막에 `[]` 토큰을 급하게 도입했는데, `a b []`는 `a[b]`로 생각하면 될 것 같습니다. 우선순위/결합성은 멤버 접근 연산자와 같습니다. 이번에는 규칙에 뭔가 반영할 게 있는 것 같네요.

#### 규칙 정리 (6)

1. 피연산자는 그대로 출력으로 빼낸다.
1. 여는 괄호는 스택의 끝처럼 취급한다. 아래에서 `스택의 끝`이라고 할 때는 무조건 실제 스택의 끝 *혹은* 여는 괄호의 의미로 해석한다.
	* `(`, `[`를 여는 괄호로 취급한다.
1. 닫는 괄호는 입력의 끝처럼 취급한다. 아래에서 `입력의 끝`이라고 할 때는 무조건 실제 입력의 끝 *혹은* 닫는 괄호의 의미로 해석한다.
	* `)`, `]`를 닫는 괄호로 취급한다.
1. 연산자는 스택에 넣는다. 그 전에...
	1. 스택에 자신보다 "가벼운", 즉 먼저 연산되는 연산자가 있으면 `스택의 끝`에 도달하거나 그 연산자와 합칠 수 있을 때까지 모두 출력으로 빼낸다.
		1. 우선순위가 높을수록 더 가볍다.
		1. 우선순위가 같으면 아래와 같이 처리한다.
			1. 좌결합성이면 입력에서 먼저 나오는 연산자가 더 가볍다.
			1. 우결합성이면 입력에서 나중에 나오는 연산자가 더 가볍다.
	1. 스택의 꼭대기에 있는 연산자와 합칠 수 있는 경우 합친다.
		1. `?`와 `:`는 `?:`로 합쳐진다.
1. 입력이 `끝나면` 스택을 `끝까지` 비우고 출력으로 빼낸다. 그런 뒤...
	1. 그 `입력의 끝`이 일반 닫는 괄호(`)`)일 경우에는 해당되는 괄호 쌍을 모두 없앤다.
	1. **배열 원소 접근 연산자 닫는 부분(`]`)일 경우에는 해당되는 괄호 쌍을 모두 없애고, 출력에 `[]`를 추가로 넣는다.** (New!)

### 함수 호출 연산자

함수 호출 연산자도 여러 형태로 표현할 수 있습니다. 가령 `foo(bar, baz)`는 이렇게 만들 수 있습니다.

* `foo` `bar` `baz` `(2)` (`2`는 인자의 개수)
* `bar` `baz` `foo(2)`

처음에는 연산자도 함수의 문법적 설탕으로 볼 수 있고([영문 위키백과](https://en.wikipedia.org/wiki/Shunting-yard_algorithm)에서도 이 관점을 따르는 듯합니다) 멤버 접근 연산자를 `a` `.b`로 묶기로 했으니 후자로 구현할까도 생각해봤는데, 오히려 함수를 피연산자로 취급할 수 있는 언어도 많고 컴파일 타임에 접근할 멤버가 확정되는 멤버 접근 연산자와 달리 이쪽은 호출할 함수를 런타임이 돼서야 알 수도 있으니까(C/C++ 함수 포인터나 JavaScript의 고차함수와 같이) 그냥 전자로 구현하기로 했습니다.

**함수 호출 연산자는 `f(n)`로 표현하며, `n`+1항 연산자처럼 취급합니다.** 처음으로 오는 피연산자가 호출할 함수, 나머지는 전부 그 함수에 전달할 인자입니다. 원래 `f` 없이 그냥 `(n)`만 넣으려고 했는데, 쓰다 보니 아래의 `f(`~`f)`, `f()`와 일관성이 있어야 할 것 같아 `f`를 넣었습니다.

인자 분리 "연산자"도 필요하니 `,`로 정하겠습니다. 나중에 인자 분리가 아닌 `,`도 넣을 예정이고, 이쪽은 인자 분리 연산자와 달리 좌변의 값을 버리므로(`1, 2`는 보통 2로 평가됩니다) 다른 연산자로 분리할까 생각했는데, 어차피 여는 괄호와 합칠 예정이므로 분리하지 않기로 했습니다.

맞습니다. 함수 호출 문법 역시 삼항 분기 연산자와 같이 **멀티파트 연산자**입니다. 위에서 얘기했듯이 여는 괄호와 `,`를 합칠 수 있을 것 같으니 이 규칙을 적용해서 `foo(a, b + c, d)`를 변환해 봅시다.

1. 초기 상태
	* 입력: `foo` `f(` `a` `,` `b` `+` `c` `,` `d` `f)` (괄호와 구분하기 위해 `f(`로 표기함)
	* 스택: *(비어 있음)*
	* 출력: *(비어 있음)*
1. (한 단계 진행)
	* 입력: `f(` `a` `,` `b` `+` `c` `,` `d` `f)`
	* 스택: *(비어 있음)*
	* 출력: **`foo`**
1. 함수 호출의 시작입니다! 인자의 개수를 기억하고 있어야 하니 방금 넣은 여는 괄호에 같이 메모해 둡시다. 왜 0이 아니라 1인지는 나중에 설명하겠습니다.
	* 입력: `a` `,` `b` `+` `c` `,` `d` `f)`
	* 스택: **`f(1`**
	* 출력: **`foo`**
1. (한 단계 진행)
	* 입력: `,` `b` `+` `c` `,` `d` `f)`
	* 스택: `f(1`
	* 출력: `foo` **`a`**
1. `,`가 들어왔습니다.
	* 스택을 `끝까지`(`f(1`까지) 비웁니다. 아무 것도 없네요.
		* 입력: `,` `b` `+` `c` `,` `d` `f)`
		* 스택: `f(1`
		* 출력: `foo` `a`
	* 방금 읽은 `,`를 기준으로 새로운 인자를 읽기 시작했으니 `f(1`와 합쳐 `f(2`로 만듭시다.
		* 입력: `b` `+` `c` `,` `d` `f)`
		* 스택: **`f(2`**
		* 출력: `foo` `a`
1. (세 단계 진행)
	* 입력: `,` `d` `f)`
	* 스택: `f(2` **`+`**
	* 출력: `foo` `a` **`b`** **`c`**
1. `,`를 처리합니다.
	* 스택을 `끝까지` 비웁니다.
		* 입력: `,` `d` `f)`
		* 스택: `f(2`
		* 출력: `foo` `a` `b` `c` **`+`**
	* `f(2`와 합쳐 `f(3`로 만듭니다.
		* 입력: `d` `f)`
		* 스택: **`f(3`**
		* 출력: `foo` `a` `b` `c` `+`
1. (한 단계 진행)
	* 입력: `f)`
	* 스택: `f(3`
	* 출력: `foo` `a` `b` `c` `+` **`d`**
1. 함수를 닫습니다.
	* 스택을 `끝까지` 비웁니다.
		* 입력: `f)`
		* 스택: `f(3`
		* 출력: `foo` `a` `b` `c` `+` `d`
	* 이번에는 함수 호출이 끝났으므로 `f(3`와 `f)`를 모두 지우고 인자의 개수를 출력으로 넣습니다.
		* 입력: *(비어 있음)*
		* 스택: *(비어 있음)*
		* 출력: `foo` `a` `b` `c` `+` `d` **`f(3)`**
1. 알고리즘이 끝났습니다.
	* 출력: **`foo a b c + d f(3)`**

이 정도면 함수 호출 연산자는 얼추 구현한 것 같은데, 문제가 하나 있습니다.

#### 인자 개수 패러독스

지금 이 상태의 알고리즘과 연산자 집합으로는 **인자가 없는 함수를 처리할 수 없습니다**. 인자 개수와 `,`의 개수가 일치하지 않기 때문에 생기는 문제입니다.

| 함수 호출 | 인자 개수 | `,` 개수 |
| - | - | - |
| `foo()` | **0** | **0** |
| `foo(1)` | **1** | **0** |
| `foo(1, 2)` | 2 | 1 |
| `foo(1, 2, 3)` | 3 | 2 |
| `foo(1, 2, 3, 4)` | 4 | 3 |

인자가 없는 함수를 어떻게든 예외로 만들어야 할 것 같은데, 별도 규칙으로 넣으면 규칙이 너무 더러워지니 포기했고 인자 없는 함수 호출 연산자 `f()`를 따로 만들기로 했습니다. 토큰화 단계에서 `f(` 바로 다음에 `f)`가 나오면 합치면 되니 파싱 단계에서 예외적으로 처리하는 것보다 깔끔해 보입니다.

이쯤에서 연산자 표와 규칙을 정리해 봅시다. 이때 `f(`~`f)`는 닫히기 전에는 괄호로 취급되어 우선순위가 없지만, 닫히고 나면 우선순위가 생기는 점에 유의해 주세요.

| 연산자 | 설명 | 우선순위 | 결합성 |
| - | - | - | - | - |
| `(`~`)` | 괄호 | - | - |
| `[`~`]` | 배열 원소 접근 (열린 형태) | - | - |
| `f(n`~`f)` | 인자가 있는 함수 호출 (열린 형태)[^fn_function_call] | - | - |
| `.<identifier>` | 멤버 접근 | 7 | 좌 |
| `[]` | 배열 원소 접근 (닫힌 형태) | 7 | 좌 |
| `f(n)` | 인자가 있는 함수 호출 (닫힌 형태) | 7 | 좌 |
| `f()` | 인자가 없는 함수 호출 | 7 | 좌 |
| `post++` | 후위 증가 | 7 | 좌 |
| `post--` | 후위 감소 | 7 | 좌 |
| `u+` | 양의 부호 | 6 | 우 |
| `u-` | 음의 부호 | 6 | 우 |
| `pre++` | 전위 증가 | 6 | 우 |
| `pre--` | 전위 감소 | 6 | 우 |
| `**` | 거듭제곱 | 5 | 우 |
| `*` | 곱셈 | 4 | 좌 |
| `/` | 나눗셈 | 4 | 좌 |
| `%` | 나머지 | 4 | 좌 |
| `+` | 덧셈 | 3 | 좌 |
| `-` | 뺄셈 | 3 | 좌 |
| `?`~`:`, `?:` | 삼항 분기 | 2 | 우 |
| `,` | 인자 분리 연산자 | 1 | 좌 |

#### 규칙 정리 (7)

1. 피연산자는 그대로 출력으로 빼낸다.
1. 여는 괄호는 스택의 끝처럼 취급한다. 아래에서 `스택의 끝`이라고 할 때는 무조건 실제 스택의 끝 *혹은* 여는 괄호의 의미로 해석한다.
	* `(`, `[`, `f(n`(`n`은 양의 정수)를 여는 괄호로 취급한다.
1. 닫는 괄호는 입력의 끝처럼 취급한다. 아래에서 `입력의 끝`이라고 할 때는 무조건 실제 입력의 끝, 닫는 괄호 *혹은* 구분자의 의미로 해석한다.
	* `)`, `]`, `f)`를 닫는 괄호로 취급한다.
1. 연산자는 스택에 넣는다. 그 전에...
	1. 스택에 자신보다 "가벼운", 즉 먼저 연산되는 연산자가 있으면 `스택의 끝`에 도달하거나 그 연산자와 합칠 수 있을 때까지 모두 출력으로 빼낸다.
		1. 우선순위가 높을수록 더 가볍다.
		1. 우선순위가 같으면 아래와 같이 처리한다.
			1. 좌결합성이면 입력에서 먼저 나오는 연산자가 더 가볍다.
			1. 우결합성이면 입력에서 나중에 나오는 연산자가 더 가볍다.
	1. 스택의 꼭대기에 있는 연산자와 합칠 수 있는 경우 합친다.
		1. `?`와 `:`는 `?:`로 합쳐진다.
		1. **모든 `n`에 대해 `f(n`와 `,`는 `f(n+1`로 합쳐진다.** (New!)
	1. **연산자가 함수 호출 여는 연산자(`f(n`)일 경우 `n`의 초깃값은 1이다.** (New!)
1. 입력이 `끝나면` 스택을 `끝까지` 비우고 출력으로 빼낸다. 그런 뒤...
	1. 그 `입력의 끝`이 일반 닫는 괄호(`)`)일 경우에는 해당되는 괄호 쌍을 모두 없앤다.
	1. 배열 원소 접근 연산자 닫는 부분(`]`)일 경우에는 해당되는 괄호 쌍을 모두 없애고, 출력에 `[]`를 추가로 넣는다.
	1. **함수 호출 연산자(`f(n`~`f)`)일 경우에는 해당되는 괄호 쌍을 모두 없애고, 출력에 `(n)`를 추가로 넣는다.** (New!)

규칙에 점점 군더더기가 생기는 기분입니다. 다음 문단에서 고쳐 보겠습니다.

# 진짜마지막: 연산자 전부 넣고 다듬기

규칙을 잘 보면 연산자 목록은 알고리즘에서 다루지 않고 별도의 표로 정리했지만, 여닫는 괄호 목록과 연산자 합성 규칙은 그렇지 않은 것을 확인할 수 있습니다. 아래에 작성할 최종 버전에서는 전부 뺄 예정입니다.

그리고 글을 여기까지 쓸 동안 무시한 게 하나 있는데(사실은 글을 계속 고치느라 자연스럽게 넣지 못한 얘기긴 하지만), **모든 괄호는 멀티파트 연산자입니다**. 그렇기 때문에 여는 괄호와 닫는 괄호도 입력의 끝 어쩌고 하는 대신 멀티파트 연산자 합성 규칙으로 다룰 수 있는데, 이렇게 하면 다음과 같은 부작용이 생깁니다.

* 여는 괄호와 닫는 괄호가 합쳐지는 규칙이 추가됩니다.
* 닫는 괄호는 다른 모든 연산자를 "치울" 수 있어야 하므로 가장 낮은 우선순위(편의상 0)를 부여받습니다.
* "닫는 괄호" 분류와 `입력의 끝` 정의가 필요 없어졌으므로 없앱니다. 이제 입력의 끝이라고 하면 문자 그대로 실제 입력의 끝만을 의미합니다.
* 여는 괄호는 여전히 우선순위 놀음으로 대체할 수 없는 역할을 맡으므로 계속 여는 괄호로 분류하고 우선순위를 부여하지 않습니다.

| 연산자 | 설명 | 우선순위 | 결합성 |
| - | - | - | - | - |
| `(` | 여는 괄호 | - | - |
| `[` | 배열 원소 접근 (여는 부분) | - | - |
| `f(n` | 인자가 있는 함수 호출 (여는 부분)[^fn_function_call] | - | - |
| `.<identifier>` | 멤버 접근 | 16 | 좌 |
| `[]` | 배열 원소 접근 (닫힌 형태) | 16 | 좌 |
| `f(n)` | 인자가 있는 함수 호출 (닫힌 형태) | - | - |
| `f()` | 인자가 없는 함수 호출 | 16 | 좌 |
| `post++` | 후위 증가 | 16 | 좌 |
| `post--` | 후위 감소 | 16 | 좌 |
| `!` | 논리 NOT | 15 | 우 |
| `~` | 비트 NOT | 15 | 우 |
| `u+` | 양의 부호 | 15 | 우 |
| `u-` | 음의 부호 | 15 | 우 |
| `pre++` | 전위 증가 | 15 | 우 |
| `pre--` | 전위 감소 | 15 | 우 |
| `**` | 거듭제곱 | 14 | 우 |
| `*` | 곱셈 | 13 | 좌 |
| `/` | 나눗셈 | 13 | 좌 |
| `%` | 나머지 | 13 | 좌 |
| `+` | 덧셈 | 12 | 좌 |
| `-` | 뺄셈 | 12 | 좌 |
| `<<` | 비트 왼쪽 시프트 | 11 | 좌 |
| `>>` | 비트 오른쪽 시프트 | 11 | 좌 |
| `>>>` | 부호 없는 비트 오른쪽 시프트 | 11 | 좌 |
| `<` | 미만 | 10 | 좌 |
| `<=` | 이하 | 10 | 좌 |
| `>` | 초과 | 10 | 좌 |
| `>=` | 이상 | 10 | 좌 |
| `==` | 같음 | 9 | 좌 |
| `!=` | 다름 | 9 | 좌 |
| `&` | 비트 AND | 8 | 좌 |
| `^` | 비트 XOR | 7 | 좌 |
| `|` | 비트 OR | 6 | 좌 |
| `&&` | 논리 AND | 5 | 좌 |
| `||` | 논리 OR | 4 | 좌 |
| `?`~`:`, `?:` | 삼항 분기 | 3 | 우 |
| `=`, `**=`, `*=`, `/=`, `%=`, `+=`, `-=`, `<<=`, `>>=`, `>>>=`, `&=`, `^=`, `|=` | 할당 | 2 | 우 |
| `,` | 쉼표, 인자 분리 연산자 | 1 | 좌 |
| `)` | 닫는 괄호 | 0 | - |
| `]` | 배열 원소 접근 (닫는 부분) | 0 | - |
| `f)` | 인자가 있는 함수 호출 (닫는 부분) | 0 | - |

위 표에서 우선순위가 부여되지 않은(`-`로 표기된) 연산자는 여는 괄호로 취급합니다.

어떤 연산자는 스택의 다른 연산자와 합쳐져 새로운 연산자가 됩니다. 아래 표에 결합 규칙을 정리해 두었습니다. 이때 쉼표는 결합자로도 사용하지만 `f(n`이 없을 경우 일반 연산자로도 사용되는 점에 유의해 주세요.

| 연산자 조합 | 결합 결과 |
| - | - |
| `(` + `)` | *(연산자 없음)* |
| `[` + `]` | `[]` |
| `f(n` + `f)` | `f(n)` |
| `f(n` + `,` | `f(n+1` |
| `?` + `:` | `?:` |

## **차량기지 알고리즘 최종 규칙**

1. 피연산자는 그대로 출력으로 빼낸다.
1. 여는 괄호는 스택의 끝처럼 취급한다. 아래에서 `스택의 끝`이라고 할 때는 무조건 실제 스택의 끝 *혹은* 여는 괄호의 의미로 해석한다.
	* 여는 괄호는 위의 리스트에 별도로 나열되어 있다.
1. 연산자는 스택에 넣는다. 그 전에...
	1. 스택에 자신보다 "가벼운", 즉 먼저 연산되는 연산자가 있으면 `스택의 끝`에 도달하거나 그 연산자와 합칠 수 있을 때까지 모두 출력으로 빼낸다.
		1. 우선순위가 높을수록 더 가볍다.
		1. 우선순위가 같으면 아래와 같이 처리한다.
			1. 좌결합성이면 입력에서 먼저 나오는 연산자가 더 가볍다.
			1. 우결합성이면 입력에서 나중에 나오는 연산자가 더 가볍다.
	1. 스택의 꼭대기에 있는 연산자와 합칠 수 있는 경우 합친다.
		* 연산자 결합 규칙은 위의 표에 별도로 나열되어 있다.
1. 입력이 끝나면 스택을 끝까지 비우고 출력으로 빼낸다.

# 끝끝끝끝진짜끝!!!

**아무 표현식이나 파싱할 수 있는 10(+α)줄짜리 차량기지 알고리즘, 이로써 완성입니다!** 다른 연산자로 구성된 식을 후위식으로 고치고 싶다면 알고리즘 자체를 고칠 필요 없이 위의 연산자 표에 연산자를 넣고 빼거나, 우선순위나 결합성을 바꾸거나, 여는 괄호나 괄호 한정자 규칙만 바꾸면 됩니다. 

이 글을 쓰면서 시행착오도 해보고(지금 이것보다 더 비효율적으로 짜려다가 수정한 일이 매우 많이 있었습니다) 이것저것 고민하다 보니까 이 알고리즘을 조금 더 깊게 이해하고, 입맛에 맞춰서 고쳐 써볼 수도 있게 된 것 같습니다.

웹서핑을 하면서 어떻게에 대한 설명은 많이 봤어도 왜 규칙이 이런지에 대한 의문이 계속 남아있어서 답답했는데, 이 글을 읽으면서 어느 정도 풀리셨기를 바랍니다(원래 이 글의 목표기도 했습니다). 혹시 어려웠거나 답답한 부분이 있으면 댓글로 물어봐주세요(TODO)![^fn_comment_todo]

# TODO

이 시리즈의 목표가 실제로 프로그램을 짜는 거였으니, 다음 글에서는 이 글에서 언급 안 하고 넘어갔던 토큰화 얘기를 해보려고 합니다. 실제 작동하는 코드는 더 이따가 추가하겠습니다.

여건이 되면 글 이곳저곳에 추가한 너저분한 예제를 인터랙티브로 고쳐볼 생각도 있습니다. 어차피 지킬 써서 만드는 제 블로그인데 아무것도 절 막을 수 없죠 ~~죄송합니다.~~

[^fn_polish]: 폴란드가 나오는 게 다소 뜬금없어 보일 수 있는데, 이 이름은 *폴란드의* 논리학자인 얀 우카시에비치(Jan Łukasiewicz)가 고안한 [폴란드 표기법](https://ko.wikipedia.org/wiki/%ED%8F%B4%EB%9E%80%EB%93%9C_%ED%91%9C%EA%B8%B0%EB%B2%95)을 거꾸로 했다는 의미로 붙어졌습니다.
[^fn_parentheses_vs_multipart]: `?`이 여는 괄호, `:`이 닫는 괄호라고 해석할 수도 있고 이 글에서처럼 그냥 한 연산자의 서로 다른 부분이라고 해석할 수도 있는데, 전자의 경우 `a ? b, c : d`가 `a ? (b, c) : d`로 해석되어 올바른 표현식이 되고(C/C++) 후자의 경우 `(a ? b), (c : d)`로 해석되어 잘못된 표현식이 됩니다(자바스크립트).
[^fn_function_call]: 괄호 내부의 n은 인자의 개수이다.
[^fn_comment_todo]: 아직 이 블로그에 댓글 기능을 넣지 않았습니다. 곧 추가할 예정이니 기다려 주세요.