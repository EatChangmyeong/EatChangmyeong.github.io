---
layout: post
title: "흥미 위주로 알아보는 μ-재귀 함수"
tags:
- Computation
- Interactive
style: "/assets/post-styles/interest-driven-mu-recursive-functions.css"
script: "/assets/post-scripts/interest-driven-mu-recursive-functions.js"
comments: true
---

{::comment}&#40;과 &#41;은 VS Code에서 맞는 괄호 하이라이팅을 부숴먹지 않기 위해(애초에 왜 하이라이팅이 잘 안 되는지는 모르겠는데) 닫는 괄호 대신 사용했습니다. 혹시 EatChangmyeong/EatChangmyeong.github.io에서 오셨다면 이 건으로 이슈나 풀 리퀘를 넣지 말아 주세요.{:/}

> *ー모르는 단어다.*

이번에는 갑자기 뜬금없는 주제에 안착했네요. 어쩌다가 이렇게 됐냐면...

* solved.ac 디스코드에서 누군가가 "[설명 불가능한 실수](https://en.wikipedia.org/wiki/Definable_real_number)도 존재한다"라고 한 것을 읽었음
	* 실수는 [셀 수 없이](https://ko.wikipedia.org/wiki/가산_집합) 무한하지만 실수에 대한 (길이가 유한한) 설명의 개수는 셀 수 있으므로
	* 채팅으로 이 주제를 언급하신 분께 사전 허락을 받고 싶었지만 디스코드 검색에 해당 채팅이 잡히지 않았습니다.
* 관련해서 [계산 불가능한 실수](https://en.wikipedia.org/wiki/Computable_number) 언급이 나왔었음
* 심심해서 위키백과에서 [Programming language theory](https://en.wikipedia.org/wiki/Programming_language_theory)를 찾아보기로 함
* 
	> "Theory of programming"은 여기로 리다이렉트됩니다. 어떤 문제를 해결할 수 있는지를 다루는 컴퓨터과학 분야에 대해서는 [Theory of computation](https://en.wikipedia.org/wiki/Theory_of_computation)을 참조하십시오.
* 오 저번에 디코에서 읽었던 그거 생각난다 이것도 읽어봐야지
* [오 튜링 완전한 체계가 람다 대수 말고 또 있다고?](https://en.wikipedia.org/wiki/Theory_of_computation#Models_of_computation)

이 글에서는 바로 위의 "또" 중 하나를 다룹니다. 참고로 위의 위키백과 글에서 언급한 튜링 완전한 계산 모형은 다음과 같습니다.

* [**람다 대수**](https://ko.wikipedia.org/wiki/람다_대수)
	* 단항 함수를 자유롭게 만들고 합성할 수 있습니다. 함수 이외에 다른 것은 존재하지 않으며 [처치 숫자](https://en.wikipedia.org/wiki/Church_encoding) 등의 방법을 이용해 만들어야 합니다.
	* 함수형 프로그래밍의 기초를 이룹니다. [컬리 기술 블로그](https://helloworld.kurly.com/blog/lambda-calculus-1/) 등에서 쉬운 한국어 설명을 찾아볼 수 있습니다.
* [**콤비네이터 논리**](https://en.wikipedia.org/wiki/Combinatory_logic) (Combinatory logic)
	* 람다 대수와 비슷하지만 몇 개의 정해진 콤비네이터(자유 변수가 없는 람다 함수)만 사용할 수 있습니다. 모든 람다 함수는 두 개의 콤비네이터 $$S$$와 $$K$$로만 표현할 수 있음이 알려져 있습니다[^fn-ski-combinator].
	* 이 계산 모형에 기초한 *난해한* 프로그래밍 언어 [Unlambda](https://en.wikipedia.org/wiki/Unlambda)가 있습니다.
	* 번역어를 잘 찾은 건지 모르겠네요. "조합 논리"는 혼동이 있을 것 같아 사용하지 않았습니다.
* [**μ-재귀 함수**](https://ko.wikipedia.org/wiki/Μ-재귀_함수)
	* **이 글의 주제입니다.**
	* "뮤 재귀 함수"라고 읽습니다.
* [**마르코프 알고리즘**](https://en.wikipedia.org/wiki/Markov_algorithm)
	* 정해진 알파벳으로 이루어진 문자열을 주어진 치환 규칙의 집합에 따라 찾아 바꾸는 알고리즘입니다.
	* 이 계산 모형에 기초한 프로그래밍 언어 [Refal](https://en.wikipedia.org/wiki/Refal)과 *난해한* 프로그래밍 언어 [Thue](https://en.wikipedia.org/wiki/Thue_(programming_language))가 있습니다.

원래는 제가 잘 알고 있는 주제 위주로 블로그 글로 적었는데, 첫 문단에서 눈치채셨겠지만 제가 접한 지 얼마 안 되는 분야로 글을 쓰고 있기 때문에 주제에 대한 이해도가 비교적 낮을 수 있습니다. 재미있어 보이고 자주 다뤄지는 주제가 아닌 것 같아서 글로 남기고 있으니 틀린 곳을 발견하셨다면 댓글로 알려주세요.

# 원시 재귀 함수

μ-재귀 함수를 처음부터 전부 이해하려고 하면 체할 수 있으니 이것보다 더 작은 개념인 [**원시 재귀 함수**](https://ko.wikipedia.org/wiki/원시_재귀_함수)부터 차근차근 살펴봅시다. 여기서 "재귀 함수"라는 단어는 프로그래밍에서의 재귀 함수와 다른 개념인 점에 유의해 주세요.

이 계산 모형에는 세 종류의 수학적 대상만이 존재합니다.

* **0 이상의 정수** (이 글에서는 그냥 "정수"라고 하겠습니다.)
* **함수**
	* 함수마다 정해진 개수만큼의 정수를 받을 수 있습니다. 매개변수가 $$n$$개인 함수를 $$n$$-ary라고 하며&#40;"$$n$$변수"로 번역하겠습니다&#41;, $$n$$ 역시 정수입니다.
* **연산자**
	* 정수에 대한 연산자는 아니고, 여러 함수를 조합해 새로운 함수를 만듭니다.

위에서 잠깐 살펴본 람다 대수와는 달리 함수의 인자로는 함수가 아니라 정수만 들어갈 수 있습니다. 여기서는 그 대신 기존의 함수끼리 연산하여 더 복잡한 함수를 만들어냅니다.

다음 방법으로 만든 함수만을 **원시 재귀 함수**라고 합니다. 별 말이 없으면 대문자는 함수, 소문자는 정수를 나타냅니다.

* 기본 함수
	* **상수 함수** $$C^k_n$$
		* 다변수 버전 상수함수입니다. $$k$$개의 매개변수를 받고 항상 $$n$$을 함숫값으로 가집니다.
		* \$$C^k_n(x_1, \cdots, x_k) = n$$
	* **다음 수 함수** $$S$$
		* 매개변수에 1을 더하는 일변수 함수입니다.
		* \$$S(x) = x + 1$$
	* **사영 함수** $$P^k_i$$ ($$1 \leq i \leq k$$)
		* 다변수 버전 항등함수입니다. $$k$$개의 매개변수 중 $$i$$번째 매개변수를 함숫값으로 가집니다.
		* \$$P^k_i(x_1, \cdots, x_k) = x_i$$
* 기본 함수들을 아래 연산자로 유한 번 연산한 것
	* **합성 연산자** $$\circ$$
		* 일변수 함수의 합성을 다변수 함수에 대해 확장한 것으로 생각할 수 있습니다.
		* $$m$$변수 함수 $$H$$와 $$m$$개의 $$k$$변수 함수 $$G_i$$ ($$1 \leq i \leq m$$)에 대해, $$k$$변수 함수 $$F = H \circ (G_1, \cdots, G_m)$$라 하면 다음이 성립합니다. \
		> \$$F(x_1, \cdots, x_k) = H(G_1(x_1, \cdots, x_k), \cdots, G_m(x_1, \cdots, x_k))$$
		* $$m = 1$$이면 괄호를 생략할 수 있습니다&#40;$$H \circ G$$&#41;.
	* **원시 재귀 연산자** $$\rho$$
		* 프로그래밍 언어에서 `for`문에 대응하는 연산자로 생각할 수 있습니다.
		* $$k$$변수 함수 $$G$$와 $$(k + 2)$$변수 함수 $$H$$에 대해, $$(k + 1)$$변수 함수 $$F = \rho(G, H)$$라 하면 다음이 성립합니다. \
		> \$$F(0, x_1, \cdots, x_k) = G(x_1, \cdots, x_k)$$
		> 
		> \$$F(S(y), x_1, \cdots, x_k) = H(y, F(y, x_1, \cdots, x_k), x_1, \cdots, x_k)$$
		* rho라고 읽습니다. Recursion의 R에서 따온 것 같습니다.

기본 함수 하나하나는 어렵지 않은데 연산자는 조금 헷갈리네요.

## 합성 연산자

두 가지 연산자 중 비교적 쉬운 것은 합성 연산자입니다. 학교에서 배운 $$(H \circ G)(x) = H(G(x))$$를 기억하고 계실 텐데, 느닷없이 $$H$$를 $$m$$변수로, $$G$$를 $$k$$변수로 만들면 합성 연산자를 얻습니다. 단, $$H$$에 매개변수를 $$m$$개 전달해줘야 하니 $$H$$의 매개변수 자리에 들어가 있는 $$G$$도 함수 하나가 아닌 $$m$$개가 되어야 합니다.

기본 함수와 합성 연산자를 이용해 간단한 함수를 만들 수 있습니다.

* 2를 더하는 함수: $$S \circ S$$
	* \$$(S \circ S)(5) = S(S(5)) = S(6) = 7$$
* 3을 더하는 함수: $$S \circ S \circ S$$
	* \$$(S \circ S \circ S)(5) = (S \circ S)(S(5)) = S(S(S(5))) = 8$$
* 함숫값이 1인 2변수 상수 함수: $$S \circ C^0_0 \circ (k = 2)$$
	* 이론상 0변수 함수도 합성할 수 있습니다. $$m = 0$$개의 $$k$$변수 함수가 필요한데 이대로라면 $$k$$가 얼마인지 알 수 없으니 괄호 안에 $$k$$를 표기하는 것으로 하겠습니다.
	* \$$(S \circ C^0_0 \circ (k = 2))(3, 4) = S(C^0_0()) = 1$$
	* 이렇게 $$C^0_0$$, $$S$$, $$\circ$$만으로 임의의 $$C^k_n$$을 만들 수 있기 때문에 상수 함수 중 $$C^0_0$$만 기본 함수로 넣는 경우도 있고, 이때는 $$C^0_0$$을 그냥 $$0$$으로 표기하기도 합니다.
* 두 매개변수의 자리 바꾸기: 임의의 이변수 함수 $$F$$에 대해 $$F \circ (P^2_2, P^2_1)$$
	* \$$(F \circ (P^2_2, P^2_1))(3, 4) = F(P^2_2(3, 4), P^2_1(3, 4)) = F(4, 3)$$
* 빈 매개변수 자리에 기본값 넣기: $$F \circ (P^1_1, C^1_k)$$
	* \$$(F \circ (P^1_1, C^1_2))(7) = F(P^1_1(7), C^1_2(7)) = F(7, 2)$$

솔직히 이런 함수만 만들어서 누구 코에 붙이나 싶네요.

## 원시 재귀 연산자

이 블로그가 *개발* 블로그인 걸 생각하면 설명을 냅다 코드로 해도 괜찮지 않을까 싶습니다. 원시 재귀 연산자를 의사코드로 표현하면 다음과 같습니다.

{:.pseudocode}
```
def rho(G, H)(y, ...args):
	result = G(...args)
	for i in [0, y):
		result = H(i, result, ...args)
	return result
```

$$G$$는 일종의 "베이스 케이스"고, 한 번 반복할 때마다 $$H$$에 반복 횟수, 이전 반복의 결과, 나머지 매개변수를 인자로 넘겨서 다음 결과를 계산합니다. 엄밀성 다 던져놓고 더 대충 설명하자면 $$\rho(G, H)(x) = H^x \circ G$$인 편입니다.

### 덧셈 함수 만들기

이쯤에서 다음 수 함수의 존재를 기억해봅시다. 함수를 주어진 인자만큼 재귀시킬 수 있고 그 함수 자리에 다음 수 함수를 넣는다면... **덧셈 함수**를 만들 수 있습니다!

$$Add(x, y) = S^x(y)$$

그런데 원시 재귀 연산자를 사용하려면 함수 2개가 필요합니다. $$H$$ 자리의 얼개는 잡아 두었고 $$G$$는 항등함수를 쓰면 될 것 같습니다.

$$Add(x, y) = (S^x \circ P^1_1)(y)$$

...그런데 $$G$$가 일변수이니 $$H$$는 3변수여야 합니다. 위의 합성 연산자 예시에서 확인했듯이 함수를 적당히 변형할 수 있습니다. 당장 필요한 건 지금까지 반복한 결과(즉, 2번째 인자)이므로...

$$H(i, z, y) = S(z) = (S \circ P^3_2)(i, z, y)$$

종합하면 덧셈 함수는 다음과 같이 정의할 수 있습니다.

$$Add = \rho(P^1_1, S \circ P^3_2)$$

뭐가 덕지덕지 많이 붙었네요. 여기서 핵심은 $$\rho$$로 첫 인자만큼 재귀시키고 $$S$$로 다음 수를 구한다는 점입니다. 실제로 덧셈을 수행하는지 아무 정수를 넣어서 확인해 보겠습니다.

$$
\begin{align}
Add(2, 7) &= \rho(P^1_1, S \circ P^3_2)(2, 7) \\
&= (S \circ P^3_2)(1, \rho(P^1_1, S \circ P^3_2)(1, 7), 7) \\
&= S(P^3_2(1, \rho(P^1_1, S \circ P^3_2)(1, 7), 7)) \\
&= S(\rho(P^1_1, S \circ P^3_2)(1, 7)) \\
&= S((S \circ P^3_2)(0, \rho(P^1_1, S \circ P^3_2)(0, 7), 7)) \\
&= S(S(P^3_2((0, \rho(P^1_1, S \circ P^3_2)(0, 7), 7)))) \\
&= S(S(\rho(P^1_1, S \circ P^3_2)(0, 7))) \\
&= S(S(P^1_1(7))) \\
&= S(S(7)) \\
&= S(8) \\
&= 9
\end{align}
$$

계산 과정은 복잡하지만 원하는 값이 나왔네요! 이외에도 함수를 차근차근 조합해서 다음과 같은 것들을 만들 수 있습니다. 수식은 [영문 위키백과에서 가져왔습니다](https://en.wikipedia.org/wiki/Primitive_recursive_function#Examples).

* 곱셈: $$Mul = \rho(C^1_0, Add \circ (P^3_2, P^3_3))$$
* "이전 수" 연산: $$Pred = \rho(C^0_0, P^2_1)$$
	* 음수는 존재하지 않으므로 $$Pred(0) = 0$$으로 따로 정의합니다.
* "잘린 뺄셈" 연산: $$Sub = \rho(P^1_1, Pred \circ P^3_2) \circ (P^2_2, P^2_1)$$
	* 음수는 존재하지 않으므로 $$x - y < 0$$이면 $$Sub(x, y) = 0$$으로 따로 정의합니다.
* 0인지 확인하는 함수: $$IsZero = \rho(C^0_1, C^2_0)$$
	* 이하 함숫값이 참/거짓인 함수에서는 1을 참, 0을 거짓으로 가정합니다.
* 부등호
	* \$$Leq = IsZero \circ Sub$$
	* \$$Geq = Leq \circ (P^2_2, P^2_1)$$
* 조건식: $$If = \rho(P^2_2, P^4_3)$$
	* $$If(0, y, z) = z$$, $$If(S(x), y, z) = y$$를 만족합니다.
* 논리 연산
	* 논리곱: $$And = If \circ (P^2_1, P^2_2, C^2_0)$$
	* 논리합: $$Or = If \circ (P^2_1, C^2_1, P^2_2)$$
	* 논리 부정: $$Not = If \circ (P^1_1, C^1_0, C^1_1)$$
* 등호: $$Eq = And \circ (Leq, Geq)$$

함숫값으로 정수 하나만 가질 수 있다면 그렇지 않은 수학적 대상은 어떻게 표현할까 싶은데, [괴델 수](https://en.wikipedia.org/wiki/Gödel_numbering) 같은 걸 써서 나타낼 수 있다고 합니다. 예를 들어 피보나치 수열은 [괴델 베타 함수](https://en.wikipedia.org/wiki/Gödel_numbering_for_sequences) 같은 걸로 두 수를 하나로 묶는 함수와 그걸 풀어내는 함수를 만들고 나서 $$\rho$$를 적당히 써서 만들 수 있습니다. 무섭네요.

## 한계점

세 가지 기본 함수와 두 가지 연산자로 생각보다 많은 것을 만들 수 있었지만, 원시 재귀 함수에는 `H(3, H(2, H(1, H(0, G()))))` 같은 제한된 형태의 재귀 이외에 **무제한 재귀가 불가능하다**는 한계가 있습니다. 동일한 함수로 재귀를 시키려면 $$\circ$$ 연산자로 수동으로 함수를 중첩하거나, $$\rho$$ 연산자로 인자의 값만큼만 재귀할 수밖에 없습니다. 식의 길이가 유한하고 유한 번밖에 재귀할 수 없으니 [모든 식을 유한 단계 안에 계산할 수 있습니다](https://en.wikipedia.org/wiki/Machine_that_always_halts).

일반적인 튜링 기계가 특정한 입력을 받았을 때 결국 멈출지 아닐지 판정하는 알고리즘은 존재하지 않음이 알려져 있습니다([정지 문제](https://ko.wikipedia.org/wiki/정지_문제)로 유명합니다). 람다 대수 등 다른 계산 모형에서는 "표현식이 주어졌을 때 (유한 단계 안에) 값을 구할 수 있는지 판정하는 알고리즘"으로 바꿔서 생각할 수 있습니다. 원시 재귀 함수는 항상 값을 구할 수 있기 때문에 튜링 완전하지는 않겠네요.

실제로 전역적 재귀 함수인데[^fn-total-function] 원시 재귀 함수가 아닌 것 중 유명한 예시가 [**아커만 함수**](https://ko.wikipedia.org/wiki/아커만_함수)이고, 여러 버전이 있는데 가장 자주 쓰이는 정의는 이렇습니다.

* \$$Ack(0, n) = n + 1$$
* \$$Ack(S(m), 0) = Ack(m, 1)$$
* \$$Ack(S(m), S(n)) = Ack(m, Ack(S(m), n))$$

슥 보고 그대로 C 코드로 옮길 수 있을 것처럼 생겼죠? 이런 함수들도 재귀 함수의 맥락에서 계산할 수 있도록 연산자를 하나 더 정의해 봅시다.

# μ-재귀 함수

오래 기다리셨습니다! 이제 진짜로 μ-재귀 함수가 뭔지 알아볼 차례입니다.

원시 재귀 함수의 정의에 아래 연산자만 하나 더 추가한 것을 μ-재귀 함수라고 합니다.

* **최소화 연산자** $$\mu$$
	* 프로그래밍 언어에서 `while`문에 대응하는 연산자로 생각할 수 있습니다.
	* $$(k + 1)$$변수 함수 $$G$$에 대해, $$k$$변수 함수 $$F = \mu(G)$$라 하면 다음이 성립합니다. \
	> $$F(x_1, \cdots, x_k)$$의 값은 $$G(z, x_1, \cdots, x_k) = 0$$을 만족시키는 가장 작은 $$z$$이다.
	* mu라고 읽습니다. Minimization의 M에서 따온 것 같습니다.

이 함수도 냅다 코드로 옮겨 보겠습니다.

{:.pseudocode}
```
def mu(G)(...args):
	for i in [0, ∞):
		if G(i, ...args) == 0:
			return i
```

이번에는 정말 원하는 만큼 재귀를 돌릴 수 있겠네요! 이렇게 최소화 연산자를 추가한 μ-재귀 함수는 튜링 완전함이 알려져 있습니다.

그런데 정의를 보고 "$$G$$에서 절대로 0이 안 나온다면 어떻게 될지"가 신경쓰이는 분들이 계실 것 같습니다. 결론부터 말씀드리자면, 이런 경우에는 함숫값이 **없습니다!!!** 🥳🥳🥳

네, 진짜로 함숫값이 없습니다. 일반적으로 $$G$$에서 0이 안 나올지 확인하는 방법은 직접 대입해보는 방법밖에는 없기 때문에 0부터 무한대까지 다 대입해봐야 하고, μ-재귀 함수에는 이렇게 생기는 무한루프를 감지하거나 빠져나올 메커니즘이 없습니다. $$\mu$$ 연산자를 도입했더니 정지 문제도 같이 따라왔네요.

이런 식으로 함숫값이 없는("정의되지 않는다"고도 합니다) 경우가 있는 함수를 "부분 함수"(partial function)라고 합니다. 가장 간단한 예를 들자면 $$\mu(C^1_1)() = \mathrm{undefined}$$가 있고 이외에도 여러 가지 상황에서 함숫값이 정의되지 않을 수 있습니다.

위키백과에서 $$\mu$$ 연산자를 사용한 예시로는 정수 제곱근(실수 제곱근에서 소숫점 아래를 버린 것)이 있습니다. 원시 재귀 함수가 *아닌* 예시는 아쉽게도 없네요.

$$Isqrt = \mu(Not \circ Gt \circ (Mul \circ (S \circ P^2_1, S \circ P^2_1), P^2_2))$$

제가 스스로 예시를 만들어보고 싶은데(특히 아커만 함수) 제가 $$\mu$$ 연산자를 어떻게 다뤄야 할지를 몰라서 못 해보고 있습니다. 그대신 위키백과에서 본 신기한 정리를 인용해야겠네요. 솔직히 이러면 위키백과 번역글이 되는 것 같긴 한데...

## 클레이니 표준형 정리

1 이상의 모든 정수 $$k$$에 대해 다음을 만족시키는 일변수 원시 재귀 함수 $$U_k(y)$$와 $$(k + 2)$$변수 원시 재귀 함수 $$T_k(y, e, x_1, \cdots, x_k)$$가 존재한다고 합니다.

* 모든 $$k$$변수 μ-재귀 함수 $$F(x_1, \cdots, x_k)$$에 대해 다음을 만족시키는 정수 $$e$$가 존재한다.
	* \
	> \$$F(x_1, \cdots, x_k) = (U_k \circ \mu(T_k))(e, x_1, \cdots, x_k)$$

...저도 읽으면서 헷갈렸으니 너무 걱정하지는 말아주세요. 이 정리의 의의는 **모든 μ-재귀 함수는 $$\mu$$를 한 번만 써서 표현할 수 있다**는 것입니다.

여기서 위의 함수 $$T_k(x, e, x_1, \cdots, x_k)$$를 [클레이니 T 명제](https://en.wikipedia.org/wiki/Kleene's_T_predicate)라고 하는데, 괴델 수 $$e$$로 표현되는 튜링 기계[^fn-turing-machine]의 초기 상태가 $$(x_1, \cdots, x_k)$$일 때, 그 튜링 기계가 괴델 수 $$x$$로 표현되는 과정을 거쳐 정지하는지 판정하는 함수라는 것 같습니다. $$U_k(x)$$는 과정 $$x$$에서 최종 값만 뽑아내는 함수입니다. 저는 "원시 재귀 함수로는 튜링 기계를 통째로 시뮬레이션하는 건 곤란하지만 단계가 맞는지 검산하는 것은 가능하다는 접근이구나"로 이해했습니다. 계산 이론에서 중요한 역할을 하는 정리인 것 같은데 이제서야 처음 들은 느낌이라서 찜찜하네요.

# 직접 써 보자!

흥미 위주로 쓰기 시작한 글을 위키백과 번역글로 놔두기는 아까우니 아래에 μ-재귀 함수 인터프리터를 만들어 두겠습니다. 문법은 다음과 같습니다.

프로그램은 0개 이상의 함수 매크로 정의, 1개의 본문 함수, 0개 이상의 인자로 이루어집니다.

* 함수 매크로 정의는 `이름 = 함수표현식;`의 형태를 띱니다. 세미콜론은 필수이고 기존에 정의된 이름이나 기본 함수를 덮어쓰거나, 정의에 자기 자신을 포함할 수 없습니다.
	* 다른 언어와 같이 이름은 영숫자와 밑줄(A-Z, a-z, 0-9, _)로만 이루어져야 하고, 첫 글자는 숫자가 될 수 없습니다. 대소문자를 구분합니다.
* 기본 함수는 다음과 같이 쓸 수 있습니다.
	* $$C^k_n$$ = `C<k, n>`
	* $$S$$ = `S`
	* $$P^k_i$$ = `P<k, i-1>` (첨자가 0부터 시작합니다.)
* 연산자는 다음과 같이 쓸 수 있습니다.
	* $$F \circ (G_1, \cdots, G_k)$$ = `F*<G1, ..., Gk>`
	* $$F \circ G$$ = `F*<G>` or `F*G`
	* $$F \circ (k = x)$$ = `F*<x>`
	* $$\rho(F, G)$$ = `Rho<F, G>`
	* $$\mu(F)$$ = `Mu<F>`
* 본문 함수와 인자는 `함수표현식 인자 인자 인자...`의 형태를 띱니다.
* 성능상의 이유로 일부 간단한 함수를 미리 정의해 두었습니다. `__builtin_`으로 시작하고 자바스크립트 엔진을 빌려서 연산합니다.
	* `__builtin_pred`와 `__builtin_sub`는 연산한 결과가 음수이면 0으로 평가됩니다.
	* `__builtin_div`는 나눈 값에서 소숫점 아래를 버림한 값으로 평가됩니다. 0으로 나누려고 하면 무한루프에 들어갑니다.
* 꼭 필요한 경우가 아니면 함수를 호출한 값은 즉시 평가하지 않습니다. 이로 인해 인자의 값이 정의되지 않더라도 함숫값이 계산되는 경우(`C<1, 0>*Mu<C<1, 1>> = 0`)가 있습니다. 이게 수학적으로 올바른 동작인지는 모르겠네요.

파서는 [Peggy](https://peggyjs.org/)를 이용해 생성했습니다. 오류 메시지가 영어로 나오거나 일부 상황에서 알아보기 어려운 메시지가 나오는 점 양해 부탁드립니다.

<div data-script='{}'></div>

그런데 글을 이렇게 끝내기 굉장히 찜찜하네요. 뭐 더 쓸 만한 거 없나? 개인 의견 쓰기는 부담스러운데

[^fn-ski-combinator]: [보통 3종류의 콤비네이터 $$S$$, $$K$$, $$I$$를 사용하지만](https://en.wikipedia.org/wiki/SKI_combinator_calculus), $$I$$는 $$S$$와 $$K$$로 나타낼 수 있습니다. 이외에 $$B$$, $$C$$, $$Y$$ 등을 추가로 도입하는 경우도 있습니다.
[^fn-total-function]: 모든 인자의 조합에 대해 함숫값을 가지는 함수를 "전역적"(total)이라고 합니다. 그렇지 않은 함수는 "부분 함수"(partial function)라고 하며, 이 글의 더 밑에서 살펴보겠습니다.
[^fn-turing-machine]: 모든 μ-재귀 함수는 대응하는 튜링 기계가 있고, 그 역도 성립한다고 합니다.