---
layout: post
author: EatChangmyeong
actual_title: "게임메이커 8.x / GM:S 1.x 소소한 꿀팁"
edited_at: 2021-07-27
tags:
- GameMaker
comments: true
---

*이제 저도 겜스2 라이선스가 있어요! 테스트를 조금 해본 뒤 글을 전체적으로 수정할 예정입니다.*

이 글은 [KGMC에 먼저 올라왔었고](https://cafe.naver.com/crazygm/221283), 항상 다른 데로 옮길 기회만 엿보고 있다가 마침 블로그를 만들게 돼서 이때다 하고 옮겨왔습니다. 거의 9개월 전에 썼던 글을 다시 읽자니 살짝 쪽팔려서 내용에 약간의 수정도 거쳤습니다.

이 글에는 회원만 열람할 수 있는 웹사이트의 글 일부가 이미지로 올라와 있습니다. 해당 내용의 삭제를 원하신다면 dlaud5379 [at] naver.com으로 연락해 주세요!

**추가**: 마침 방금 블로그에 댓글창을 만들었으니 하는 얘기인데... 겜스2로 이것저것 테스트를 해보고 내용 업데이트가 끝나면 댓글 제보를 받을 예정입니다. 조금만 더 기다려주세요.

**추가2**: 언제부턴가 겜스1은 더 이상 실행이 되지 않네요. 글 업데이트 시점까지 실행이 안 되면 겜스1 관련 내용은 전부 지울 예정입니다.

***

[구 PlayGM에 멍멍이님이 작성하셨던 겜메 팁](https://cafe.naver.com/playgm/69477)(KGMC 아카이브 회원만 열람 가능)을 감명 깊게 읽었던 적이 있습니다. 그동안 게임메이커 스튜디오나, 굳이 겜메가 아니더라도 개발을 하면서 익힌 꿀팁...이라기보다는 꼼수나 그런 것들을 감히 저 글의 포맷을 빌려 공유해보려고 합니다.

게임메이커 8.0 영문판(이하 '겜메8'), 게임메이커: 스튜디오 1.4.9999(이하 '겜스 1.x') 기준으로 작성합니다. 다른 버전은 가지고 있지 않네요...

## 음수의 나머지는?

`mod`나 `%`(겜스 1.x) 연산자로 나머지를 구할 수 있습니다. 그런데 **나뉘는 수가 음수면 결과도 음수가 됩니다**. 나누는 수의 부호는 무관합니다.

나뉘는 수가 양수든 음수든 상관없이 양수인 결과가 나오게 하고 싶다면 `((a%b)+b)%b`를 하면 됩니다([출처](https://stackoverflow.com/questions/4467539/javascript-modulo-gives-a-negative-result-for-negative-numbers)). 출처가 왜 자바스크립트냐면, 원래 자바스크립트 코딩하다가 검색해서 안 사실이라서 그렇습니다.

## `angle_difference()`

겜스 1.x부터는 `angle_difference(ang1, ang2)`라는 함수가 추가되어 두 각 사이의 차를 쉽게 계산할 수 있습니다. 이 함수가 무슨 함수냐면, `ang2 - ang1`을 **-180도와 +180도 사이로 알아서 변환해줍니다**.

사실 [겜스 도움말](http://docs.yoyogames.com/source/dadiospice/002_reference/maths/vector%20functions/angle_difference.html)에도 당당히 올라와 있는 함수라서 꼼수...를 올리려고 쓰는 이 글과는 맞지 않는 점이 있긴 하지만 홍보가 안 됐는지 아시는 분이 거의 없어서 씁니다.

## 정확한 시간 측정

게임이 켜진 이후 흐른 시간을 측정하는 방법이 2가지 있습니다. 하나는 `current_time`, 다른 하나는 `get_timer()`(겜스 1.x)인데, 전자는 밀리초 단위(1000이 1초), 후자는 마이크로초 단위(1000000이 1초)입니다. 또 겜스에는 `delta_time`도 있는데, 말 그대로 $$\Delta t$$입니다. 이전 프레임과 현재 프레임 사이에 흐른 시간을 마이크로초 단위로 측정해줍니다. 렉이 심하거나 (리듬게임처럼) 시간 측정이 중요한 게임이라면 이 기능을 쓰는 것도 생각해볼 수 있겠습니다.

주의사항이 있다면, (겜스 스탠다드 에디션처럼) 게임 시작 전에 스플래시 창이 있을 경우 **둘 다 0부터 시작하지 않는다**는 것이 있겠습니다.

### 룸 스피드 저리가

사실 [정확한 시간 측정](#정확한-시간-측정)도 여기 올릴 만한 내용은 아닌데 올린 이유가 있습니다. 바로 **게임 내 프레임 체계를 아예 `get_timer()`로 대체해버릴 수 있다**는 것입니다. 즉, 스텝은 게임 상태를 갱신할 목적으로만 돌리고 실제 코드에는 `get_timer()`만 써서 렉이 있든 없든 일정한 속도로 게임을 돌릴 수 있습니다.

겜메/겜스의 경우 그 특유의 체계 때문에 완전히 갈아치우는 것은 무리일 수도 있겠지만, 개인적으로 이미 이렇게 돌아가는 게임을 몇 개 만들어본 입장으로서~~꼰대~~ 고수분들이라면 도전해보는 것도 나쁘지 않을 것 같습니다~~무책임~~. 덤으로 이렇게 만들면 룸 스피드를 무턱대고 9999까지 올려도 문제가 없다는 장점이 있습니다. 그럴 이유는 ~~딱히 없지만요.~~ [있구나](https://cafe.naver.com/crazygm/222639)

### Sleep의 부활

겜메에 있던 Sleep 액션이 겜스에 들어와서는 사라졌는데, 다행히 이 액션에 해당하는 코드가 있습니다.

{:.gml}
```javascript
var t = get_timer();
while(get_timer() - t < /*잠들어있을 시간 */) {}
```

한 프레임 내에 도저히 실행할 수 없는 무거운 작업이 있는데 그동안 화면 업데이트는 꾸준히 해야겠다면, 잠들어있을 시간을 `1000000 / room_speed`로 설정하고 대괄호 안에 해당하는 작업을 여러 스텝에 걸쳐 해결할 수 있도록 변형해 넣는 트릭도 있습니다.

## `while;`;;;;;;;;;

[Sleep의 부활](#sleep의-부활)에 대한 여담이지만, 다른 언어에서는 `;` 하나만 써놔도 한 문장으로 인식해서 대괄호 대신 세미콜론을 쓴 `while(...);`이 잘 실행되는데(무한루프는 제쳐두고), 겜메8에서는 Statement expected("문장이 필요합니다")라면서 런타임 오류를, 겜스에서는 malformed while statement("잘못된 while문")라면서 컴파일 오류를 뱉어버립니다. `while`이 함수인 줄 알고 끝에 세미콜론을 붙여버리는 사람들을 위한 조치라고 생각하니 수긍은 되는데, 솔직히 귀찮습니다.

## 반올림은 은행원에게

겜메/겜스는 반올림을 할 때 **은행원의 반올림**(Banker's Rounding)이라는 특수한 방법을 사용합니다. 일반적으로 반올림에서 x.5는 큰 쪽으로 올리게 되는데, 이 방법을 사용하면 **가까운 짝수 방향으로** 반올림이 됩니다. 예를 들어 `round(0.5) = 0`(*1이 아님*에 주의)이고 `round(1.5) = 2`입니다. 사실 겜스만 이런 건 아니고, 파이썬 등 반올림 함수가 이런 언어가 또 있습니다.

가끔씩 올라오는 "스프라이트가 깨져요" 문제도 이것이 원인일 수도 있습니다. 직접 재현에 실패해서 이것이 원인이다라고 확답을 할 수는 없으니 혹시 걱정된다면 그리기 함수를 쓸 때 좌표에 꼭 `round`를 씌워주세요.

### 헷갈리게 쓰인 도움말

개인적으로 겜메/겜스의 반올림 함수는 음수 처리에 대한 문서화가 빈약하다고 느껴집니다. 개인적으로 참고하려고 추가하자면...

* `round`는 음수에 대해서도 은행원의 반올림을 사용합니다.
* `floor`는 음의 무한대 방향으로 버립니다. 즉, `floor(x)`는 `x` 이하인 가장 큰 정수입니다.
* `ceil`은 양의 무한대 방향으로 올립니다. 즉, `ceil(x)`는 `x` 이상인 가장 작은 정수입니다.
* `frac(x)`의 부호는 `x`와 같습니다.
* 겜메/겜스 라이브러리에는 0의 방향으로 버리는(양수에 대해서는 `floor`처럼 동작하고 음수에 대해서는 `ceil`처럼 동작하는) 함수가 없습니다. 대신 `x div 1`로 동일한 동작을 만들 수 있습니다.

## 형형색색

겜메/겜스 둘 다 `make_color_rgb()` 대신 `$BBGGRR` 문법으로 색상을 설정할 수 있습니다. `$` 자체는 다음에 오는 것을 16진수로 인식하는 문법이며, `RR`, `GG`, `BB`에는 RGB 값을 16진수로 넣어주시면 됩니다.

혹시 위 문단이 이해가 안 되신다면 [여기](http://hslpicker.com/)서 원하는 색을 뽑고 나서 아래쪽에 나오는 '#ab94fc' 형태의 값을 2자리씩 끊고 뒤집어서 입력(`$fc94ab`)하면 됩니다. 가끔씩 6자리가 아닌 3자리('#a9f')가 나오는 경우가 있는데, '#aa99ff'처럼 2번씩 쓴 뒤 그대로 진행하시면 됩니다.

다만 겜스 1.4.9999를 쓰신다면 [특정 상황에서 심각한 버그가 있으니](https://cafe.naver.com/crazygm/218998) 꼭 숙지하시기 바랍니다. 게임이 튕긴다든지 하는 건 아닌데 그래픽이... 엄청 이상해집니다. 꼭 `$BBGGRR` 문법을 쓰지 않더라도 해당 버그가 발생합니다.

## 문자열이 못 말려

겜스 1.4.9999에서는 문자열 처리가 좀 비효율적입니다. 정확히 말하자면, `string_char_at()`의 실행 시간이 문자열 길이만큼($$O(n)$$) 걸립니다. 즉, 특정한 문자열의 모든 글자를 차례로 체크해야 한다면 문자열 길이의 제곱만큼의 시간을 소모하게 됩니다. 적당히 긴 문자열이면 상관없겠지만 몇천 글자가 넘어갔다면 60FPS 유지는 물 건너간 셈입니다.

아무래도 `string_insert()` 등 문자열 삽입/삭제를 빠르게 처리하기 위해서 `string_char_at()`의 실행 시간을 희생한 것 같습니다. 그래도 [다른 효율적인 자료구조](https://en.wikipedia.org/wiki/Rope_(data_structure))도 많은데... 어째서...

다행히 이 현상은 ~~문자열을 적당한 길이(1000글자 정도)로 자른 다음 각각의 문자열을 읽어서 해결할 수 있습니다. 실제로 제가 CastleMaze를 개발하면서 이 현상을 처음 알았고 이렇게 해결했습니다.~~ 버퍼를 써서 해결할 수 있습니다. 이 글을 처음 썼을 때는 버퍼가 있는 걸 몰랐었는데, 아직 버퍼를 능숙하게 쓰지 못하는 분들은 취소선 안에 있는 내용을 따라해도 무방합니다. 예를 들어 아래 코드로 문자열의 모든 바이트(글자가 아님에 유의하세요!)에 대해 원하는 연산을 수행할 수 있습니다.

{:.gml}
```javascript
var str = "원하는 아무 문자열...", len = string_byte_length(str);
var b = buffer_create(len + 1, buffer_fixed /*or buffer_fast*/, 1);
for(var i = 0; i < len; i++) {
    var t = buffer_peek(b, i, buffer_u8); // = ord(string_byte_at(str, i + 1))
    // t를 가지고 무언가 연산하기...
    buffer_poke(b, i, buffer_u8, t);
}
buffer_seek(b, buffer_seek_start, 0); // 이거는 없어도 되는 건지 모르겠네요
var newStr = buffer_read(b, buffer_string);
buffer_delete(b);
```

## 알람의 정수

*KGMC Budgerigar님의 제보입니다.*

**알람을 소수로 설정할 수 없습니다.** `alarm[0] += 0.5;`를 하려고 하면 0.5를 (은행원 방식으로) 반올림한 값인 0으로 인식됩니다. 보통 알람이 0일 때가 알람이 실행되는 시점인데, 소수 알람이 가능했다면 0.5에서 바로 -0.5로 건너뛰어버려서 곤란한 상황이 생기기 때문으로 추정됩니다. 그래도 왜 굳이 이렇게 했는지는 모르겠네요.

## 속도를 논하는 두 가지 방법

`hspeed`/`vspeed`와 `speed`/`direction`은 서로에게 **즉시 영향을 미칩니다**. 혹시 저 네 변수를 쓰지 않는다면 직교좌표/극좌표 변환을 저걸로 해보는 것도 괜찮을 것 같네요.

## 깊이의 수렁

*KGMC Paragon님의 제보입니다.*

겜스2 도움말에 따르면 **깊이 값이 ±16000을 넘어가는 것은 화면에 표시되지 않습니다**(테스트는 안 해봤습니다. 이 버전을 가지고 있지 않으니...). 그 대신 겜스2에는 `layer_force_draw_depth(force, depth)`라는 함수가 추가되었는데, `force`에 `true`를 넣고 `depth`에 0 정도의 적당한 값을 넣으면 거기에 해당하는 z값에 *모든 레이어를 때려박아버립니다*. 물론 드로우 순서는 `depth` 내림차순으로 유지됩니다.

웬만하면 그냥 써도 되겠지만, 겜스2 도움말에서 이렇게 언급한 건 좀 찜찜하네요.

> 이 함수는 이전 버전의 게임메이커에서 허용된 레이어 범위 바깥의 깊이를 사용하여 제작한 레거시 프로젝트에만 사용할 것을 권장합니다.
>
> Note that this is generally only for use with legacy projects from previous version of GameMaker where you could have draw depths higher or lower than the permitted layer range.

정 마음이 불편하다면 게임 로직상으로 `depth`의 범위를 줄여주면 되는데, 예를 들어 기존에 `depth = -y;`를 사용했다면 `depth = -(y * 100/room_height);`으로 0~100 사이로 바꾸는 것도 방법입니다.

### 레이어끼리너무촘촘하게붙어있는데요

*KGMC dot cat님의 제보입니다.<br>KGMC dot cat님의 이미지를 사용하였습니다.*

역시 겜스2라서 테스트는 못 해봤지만, 깊이 값을 소수로 지정하면 정확한 드로우 우선순위 지정에 애로사항이 생기는 것 같습니다. 위에서처럼 `depth = -(y * 100/room_height);`을 쓰면 깊이를 101단계로밖에 지정할 수 없는데, 아래 사진처럼 Default layer depth spacing(레이어 깊이 간격 기본값) 설정을 바꾸면 레이어끼리 깊이 간격이 넉넉히 벌어져 더 많은 단계의 깊이를 쓸 수 있습니다.

![Default layer depth spacing](/assets/post-images/gms2-default-layer-depth-spacing.png)

### 이전 버전에서는 어땠을까?

겜메 8.x에서는 화면에 표시되는 깊이 제한은 없지만, ±9,223,372,036,854,770,000 언저리를 넘어가면 게임이 튕깁니다. 부호 있는 64비트 정수형의 최댓값이 $$2^{63}-1 = 9\,223\,372\,036\,854\,775\,807$$인 것과 관련이 있어 보입니다.

겜스 1.x 역시 화면에 표시되는 깊이 제한이 없으며, 심지어 저 값을 넘어가도 잘 돌아갑니다. 화면에 depth 값을 띄워놓고 자체적으로 테스트를 해본 결과 부호 무관하게 특정한 값($$10^{18}$$ 초과)을 넘으면 정상적인 수 대신 이렇게 표시되는 것 같습니다.

```
1.
J
```

네. 1.(줄바꿈)J입니다. 도대체 왜 저러는지는 모르겠네요. 지수 표기법으로 표기하려다가 뭔가 삐끗한 것 같기도 하고요.

## 목표점에 도달하면 그대로 멈춰라

게임을 만들다 보면 원하는 점으로 움직이다가 목표점에 도착하면 지나치지 않고 정확히 그 점에서 멈춰야 할 일이 생깁니다. 이때는 개인적으로 이 코드를 유용하게 쓰고 있습니다.

{:.gml}
```javascript
x = median(y, x - dx, x + dx); //GM 8.x
x = clamp(y, x - dx, x + dx); //GM:S 1.x
```

`x`가 `y`를 향해 한 스텝에 `dx`만큼 움직이는 상황입니다. 얼핏 보면 이게 뭐 하는 코드인가 싶겠지만, 실제로 써보면 제 역할을 잘 해냅니다. 원본에는 저게 왜 되는지 증명을 넣었었지만, 여기서는 생략하겠습니다. 참고로 `dx`는 정의상 양수이지만, 실제로는 부호 상관없이 써도(`clamp`를 쓸 때는 부호를 따져야 합니다), 심지어 0을 넣어도 괜찮습니다.

### 뜻밖의 최적화

*KGMC 모션님의 제보입니다.*

[목표점에 도달하면 그대로 멈춰라](#목표점에-도달하면-그대로-멈춰라)에서 굳이 겜메와 겜스 코드를 구분해서 적은 이유가 있는데, **버전별로 가장 빠른 코드가 다르기 때문**입니다. `median()` 대신 `clamp()`를 쓰는 코드는 모션님이 제안해 주셨고, 원 출처는 [여기](https://cafe.naver.com/crazygm/221495)(KGMC 회원만 열람 가능)입니다. 사실 저걸 저기서 쓸 수 있으리라고 예상조차 못 했는데... 감사합니다.

겜메 8.x에서는 `clamp()` 함수가 없기 때문에 `median(y, x - dx, x + dx)`와 `max(x - dx, min(x + dx, y))` 중 하나를 쓸 수 있는데, 직접 테스트해본 결과 전자가 후자보다 약 40% 가량 빠릅니다. 후자가 느린 것은 아마 함수 안에 또 함수가 있어서가 아닐까 하고 조심스럽게 추측해봅니다.

한편 겜스 1.x에서는 `median(y, x - dx, x + dx)`와 `clamp(y, x - dx, x + dx)`를 쓸 수 있는데, 이것도 테스트해본 결과 후자가 전자보다 약 20% 가량 빠릅니다. `clamp()`는 `median()`과 달리 `min`과 `max`의 순서가 정해져 있고 인자 개수도 항상 3개이기 때문에 훨씬 빠를 거라고 생각했는데, 생각보다 빠르지는 않네요.

## `default:`의 반란

`switch`문을 쓸 때 **default를 맨 뒤에 쓰지 않아도 됩니다**. 중간에 끼워넣을 일이 거의 없긴 하지만 다른 `case` 구문처럼 맨 뒤가 아니라 중간에 끼워넣을 수도 있고, `break;`를 빼먹으면 다음 케이스로 넘어가는 것도 똑같습니다. 예를 들면,

{:.gml}
```javascript
switch(t) {
    default:
        show_message("Default!");
    case 5:
        show_message("5");
    break;
}
```

이런 게 가능합니다. `t = 5`일 때는 메시지 상자 `5`만 표시되고, 그렇지 않을 때는 각각 `Default!` `5`가 표시됩니다.

이런 걸 도대체 누가 쓰냐고 여쭤보신다면... 놀랍게도 **마인크래프트 자바 에디션**에서 저걸 이용하고 있습니다. 솔직히 소스를 뜯어보기 전까지 저런 게 가능하다고는 상상조차 못 했네요.

## 사느냐 죽느냐 그것이 문제로다

겜스에서는 Short-circuit evaluation을 지원합니다(겜메 8.x는 안 됩니다). 이 용어를 '단축 평가'로 번역하는 글이 있는 것 같으니 여기서도 '단축 평가'라고 하겠습니다. 이게 뭐냐면, 이 코드를 생각해 봅시다.

{:.gml}
```javascript
if(true || false) { /*...*/ }
```

`||`/`or`는 양쪽 중 하나라도 참일 경우 식 전체가 참이 되는 연산자입니다. 이미 왼쪽이 `true`라 오른쪽의 `false`는 볼 필요가 없는데, 이런 상황에서 실제로 오른쪽을 실행하지 않는 것이 단축 평가입니다. `||`뿐만 아니라 `&&`/`and`도 지원하며, 이쪽은 왼쪽이 거짓일 때 오른쪽을 무시합니다.

단축 평가를 잘 쓰면 코드 길이 최적화에 많은 도움이 되는데, 당장 예시가 잘 생각나지 않네요. 일단 생각나는 건 대충 이렇습니다.

{:.gml}
```javascript
if(instance_exists(oPlayer) && oPlayer.hp <= 0)
    gameOver();
```

이렇게 짜면 `oPlayer`가 없어도 `instance_exists()`에서 걸러지기 때문에 오류가 나지 않으며, `if`문을 2번 쓸 필요도 없습니다.

아니면 극단적인 예시긴 한데, PHP 스타일로는 대충 이런 코드를 짤 수 있습니다.

{:.gml}
```javascript
var t = instance_find(oVeryImportantObject, 0) or die();
```

말 그대로 객체 `oVeryImportantObject`의 인스턴스를 못 찾았으면 죽으라는(...) 뜻입니다. `die()`는 PHP에 있는 그대로 쓴 것이고 겜스에 내장된 함수가 아닌 점은 주의해 주세요.

성공했으면 1 이상을, 실패했으면 0 이하를 리턴하는 아무 함수/스크립트나 쓸 수 있지만 생각해보니 그런 내장함수가 별로 없는 것 같네요... 이렇게 쓸 때는 겜스의 문법적 한계 때문에 `A or B` 부분만 따로 쓸 수는 없고, `var t = `를 붙이든지 해야 합니다.

다만 코드를 줄인다고 `if`문 대신에 단축 평가만 남용하는 것은 좋지 않으며, 오히려 나중에 코드를 읽기가 어려워질 수 있습니다. 이건 겜스 2에 추가된 삼항 연산자도 마찬가지입니다.

## 로꾸거 로꾸거 로꾸거 선언해선언

*KGMC Paragon님의 제보입니다.*

겜스에서 배열을 선언할 때는 **마지막부터 선언하는 게 빠릅니다**. 예를 들어 길이가 1000인 배열 `arr`을 선언하려면 `arr[999] = 0;`부터 해놓고 나머지는 정방향이든 역방향이든 실제 들어갈 값을 넣는 방식입니다.

보통 배열에 값을 넣을 때는 아무 생각 없이 순서대로 넣게 되는데, 이렇게 하면 값을 하나 넣을 때마다 배열의 길이를 늘여야 해서 속도가 느려집니다. 요요게임즈에도 공식 최적화 팁으로 나와 있고 레퍼런스에서도 이 방법을 권장하고 있는데, 실제로 테스트해본 결과는 다음과 같습니다.

* **길이가 10,000인 배열을 100회 생성할 때**
	* 정방향 5,243,259μs
	* 역방향 195,423μs (**26.83배** 빠름)
* **길이가 100,000인 배열을 10회 생성할 때**
	* 정방향 17,988,019μs
	* 역방향 193,668μs (**92.88배** 빠름)

똑같은 실험을 2차원 배열 `arr[i, j]`로 해본 결과 `j`의 영향이 크고, `i`의 영향은 거의 없었습니다.

### 그럼 겜메에서는?

아쉽게도 선언 순서에 따라 소요 시간이 유의미하게 늘거나 줄지는 않았습니다. 실험 중에 배열 길이가 32000을 넘어갔다고 오류를 띄우는 걸 보면 길이 32000짜리 배열을 미리 선언해놓는 것일지도 모르겠네요. 그냥 추측이지만.

## 모든 것은 수

겜메/겜스의 **모든 리소스는 수입니다**. 말 그대로 스프라이트, 사운드, 백그라운드, 패스, 스크립트, 셰이더, 폰트, 타임라인, 오브젝트, 룸 전부 다요. 즉, 여러분이 코드에 `instance_create(40, 80, oPlayer);`와 같은 것을 적을 때 `oPlayer`는 내부적으로 0이든 3이든 5든 정해진 수로 취급합니다. 다만 스크립트를 실행한다고 냅다 `3('foobar');` 같은 걸 쓰면 문법 오류를 뱉고 컴파일을 안 시켜줍니다.

이때 아무 수가 마구 붙지는 않고 일정한 규칙이 있는데, 리소스 트리(왼쪽에 폴더 구조로 있는 그거)상에서 각 종류의 리소스마다 폴더는 무시하고 위쪽부터 차례대로 `0`, `1`, `2`, `3`, ...이 할당됩니다. 예를 들어 맨 위에 있는 스프라이트는 `0`, 위에서 3번째에 있는 룸은 `2`입니다.

### 스프라이트 순서대로 순회하기

카페 질문을 보다 보면 `spr1`, `spr2`, `spr3`의 세 스프라이트가 있을 때 (배열 같은 것을 쓰지 않고) '`spr1` 끝에 있는 1을 2나 3으로 바꾸고 싶어요' 같은 질문을 볼 수 있습니다. `asset_get_index()`를 쓰는 정공법도 물론 가능하지만...

{:.gml}
```javascript
var n = 1; // , 2 or 3
draw_sprite(asset_get_index('spr' + string(n)), image_index, x, y);
```

저라면 리소스 트리에서 `spr1`, `spr2`, `spr3`을 차례대로 배치하고 `spr2 = spr1 + 1`, `spr3 = spr1 + 2`인 성질을 이용해 대충 이런 코드를 짤 것입니다.

{:.gml}
```javascript
var n = 0; // , 1 or 2
draw_sprite(spr1 + n, image_index, x, y);
```

순서만 한 번 바꾸면 `asset_get_index()`보다 짧고 쉬우며 `string()`을 쓸 필요도 없고 신경쓸 것도 적습니다.

### 오묘한 함수형 프로그래밍의 세계

스크립트 이름 대신에 냅다 숫자만 쓸 수는 없지만, 그런 역할을 대신 해주는 내장함수는 있습니다. 원글에서도 34번에 언급된 내용인데,

![34. 의외로 쓸만해보이는, 그러나 어떻게 써야할 지 모를: "script_execute(스크립트명, 인자1, 인자2.. ) 함수의 진정한 의의는 스크립트의 '이름'만 적어도 된다는겁니다. 무슨 의미냐하면 `script_execute(choose(Scr_up, Scr_down, Scr_Left, Scr_Right), 3)` 이런 게 가능하다는 이야기입니다. 물론 '스크립트' 한정이고, 내장 함수는 불가능합니다."](/assets/post-images/gm-tips-34.png)

그런데, 이걸 위에서 언급했던 [모든 것은 수](#모든-것은-수)와 연결해서 생각해보면 간접적인 방법이긴 하지만 함수의 인자로 함수를 넣을 수 있고, 함수가 함수를 반환할 수도 있습니다. GML에서는 ~~아직 함수가 일급 객체(숫자나 문자열처럼 냅다 변수에 대입하거나, 별도의 처리 없이 함수에 인자로 전달하고 반환받을 수 있는 것)가 아니고,~~ 이미 있는 스크립트를 조작할 수도 없지만 그래도 이 정도면 매우 기초적인 함수형 프로그래밍이 가능합니다.

~~추가로, [2.3 문법 업데이트](https://www.yoyogames.com/blog/514/gml-updates-in-2019)로 예정된 내용을 보면 함수가 사실상 일급 객체로 다루어지는 모습을 볼 수 있습니다. 희망을 가져도 될까요...~~ [**2.3 베타에서 예고된 내용이 전부 반영되었습니다!!**](https://twitter.com/Creta5164/status/1253506352992796673)

![Methods can be assigned to any variable and all rules for variables apply to them: they can be passed around as arguments and can be used as callbacks easily for library functions. For example: `my_load_async( “filename”, function( success, error ) { if (success) { show_debug_message( “filename successfully loaded” ); else  show_debug_message( “error loading filename - “ + string(error) ); });` This calls a library function my_load_async where the second parameter is a function that can be called when the main work has been done within the library function.](/assets/post-images/gml-method.png)

## 겜스에서의 수 처리

겜스에서는 모든 수를 *배정밀도 부동소숫점*으로 저장합니다. C/C++ 같은 언어를 써보셨다면 이미 `double`로 익숙한 자료형이실 테고, 모른다고 하더라도 겁먹지 않으셔도 됩니다. 기술적인 이야기를 조금만 더 하자면, 이 자료형은 IEEE 754 표준이라서 겜스 말고도 웬만한 언어에서는 모두 지원하고 있습니다. 나쁜 소식이 있다면, 여느 기술이 다 그렇듯이 사소한 곳에서 자주 터진다는 것입니다. 아래에서 설명드리겠습니다.

겜메는 수 처리를 어떻게 하는지 잘 모르겠네요. 일단 똑같이 배정밀도 부동소숫점으로 처리하는 것 같긴 한데 [이전 버전에서는 어땠을까?](#이전-버전에서는-어땠을까)에서 언급했듯이 900경이 넘어가면 이유 없이 갑자기 터지거든요...

### $$0.1 + 0.2 \neq 0.3$$

충격적이게도 0.1 + 0.2는 0.3이 **아닙니다**. 겜스처럼 배정밀도 부동소숫점만 있는[^fn_js_bigint] 자바스크립트로 확인해 보면 이렇습니다.

![0.3: 0.3, 0.1 + 0.2: 0.30000000000000004, 0.1 + 0.2 == 0.3: false](/assets/post-images/javascript-float-error.png)

이 문제는 정말 유명해서 아예 이 문제를 소재로 <https://0.30000000000000004.com>이라는 웹사이트까지 개설되어 있습니다.

한편 겜스 1.x에서는 `0.1 + 0.2 == 0.3`이 "잘" 돌아가는데, 이건 엔진 내부에서 `math_set_epsilon()`으로 땜빵한 결과입니다. 간단히 말해서, 별다른 처리가 없는 상태에서는 오차가 0.000001 이하면 그냥 씹어먹고 `true`를 띄워줍니다. 부동소숫점 오차를 다 신경써야 되는 레벨이 아니라면 걱정 없이 개발해도 될 것 같습니다.

그래도 못 믿으시겠다면 `string_format()`으로 소숫점 아래 17자리까지 띄워보시는 걸 권장드립니다. 아래 이미지는 `math_set_epsilon(0)`(= 오차를 허용하지 않음)을 추가로 적용한 상태로 찍었습니다.

![string_format(0.1 + 0.2, 1, 17) = 0.30000000000000004, string_format(0.3, 1, 17) = 0.29999999999999999, 0.1 + 0.2 == 0.3: 0](/assets/post-images/gms-float-error.png)

### 잃어버린 정밀도

여기서 배정밀도 어쩌구의 작동 원리를 자세히 설명드리지는 않겠습니다만, 이론상 최대 약 $$1.8 \times 10^{308}$$까지의 값을 담을 수 있습니다. IEEE 754 표준에서는 무한대와 NaN(Not a Number, "수가 아님")을 추가로 정의하고 있는데 겜스에서 저 값을 쓸 수 있는지는 모르겠네요. 무한대가 정의되어 있고 쓸 수 있는 것은 확인했지만, 대놓고 코드에 `1/0` 같은 걸 적으면 무한대가 아니라 컴파일 오류가 나기 때문에 그냥 속 편하게 무한대나 NaN 같은 건 아예 안 다루려고 합니다.

그렇다고 해서 저 $$1.8 \times 10^{308}$$까지의 값을 모두 정확히 쓸 수 있는 것은 아닙니다. 부동소숫점은 소숫점이 둥둥 떠다니는("floating") 것이 기본 원리이기 때문에 수가 커질수록 소숫점 아래의 정밀도가 점점 떨어지며, ±9,007,199,254,740,991을 넘어가면 정수도 정확하게 표현할 수 없게 됩니다.

![max_safe_integer - 5 = 9007199254740986, max_safe_integer - 4 = 9007199254740987, max_safe_integer - 3 = 9007199254740988, max_safe_integer - 2 = 9007199254740989, max_safe_integer - 1 = 9007199254740990, max_safe_integer + 0 = 9007199254740991, max_safe_integer + 1 = 9007199254740992, max_safe_integer + 2 = 9007199254740992, max_safe_integer + 3 = 9007199254740994, max_safe_integer + 4 = 9007199254740996, max_safe_integer + 5 = 9007199254740996](/assets/post-images/gms-max-safe-integer.png)

물론 이 뒤로도 수가 2배가 될 때마다 정밀도도 2배씩 줄어듭니다.

이것보다 더 큰 정수를 정확히 표현해야 한다면 마켓플레이스에서 [BigNum.gml](https://sahaun.itch.io/bignumgml)같은(*KGMC Paragon님의 제보*) 큰 수 전용 라이브러리를 찾아보는 것도 좋습니다. 이런 식으로 큰 수를 표현하는 라이브러리를 다른 언어에서는 보통 `BigInt`나 `BigInteger`라고 하는 것 같습니다.

여담이지만, "부동소숫점"은 원래 의미와 정반대로 소숫점이 고정돼있는 것처럼 들리기 때문에 "둥둥소숫점"으로 바꿔 부르는 사람도 있습니다.

## 문자열이 끝나지 않아

겜메와 겜스 모두 문자열의 길이에는 메모리가 부족해서 터지는 것 이외의 제한이 딱히 없습니다. 아래 이미지는 각각 겜메와 겜스에서 `str = 'a';`로 설정해놓은 뒤 매 스텝마다 `str += str;`를 돌리면서 테스트해본 결과입니다. 왼쪽 위에 표시되는 수가 `str`의 길이입니다.

![겜메 8.x: "game.exe이(가) 응답하지 않습니다. 프로그램을 닫으면 정보를 잃을 수 있습니다." (536870912)](/assets/post-images/gm8-string-length-limit.png)

![겜스 1.x: "Fatal Memory Error: Out of Memory!" (1073741824)](/assets/post-images/gms-string-length-limit.png)

## 이벤트가 있는데 없어졌습니다

이벤트 안에 아무런 액션이나 코드도 없을 경우에는 **그 이벤트가 존재하지 않는 것으로 취급합니다**. `alarm[x]` 자동 감산이나 물리엔진 충돌 판정 등 특정 이벤트가 있어야 실행되는 것들이 가끔 있는데, 딱히 넣을 만한 내용이 없다면 Comment 액션이나 주석만 있는 코드라도 추가해야 올바르게 동작합니다.

## 누가 그걸 그렇게 써요

`=` 대신 `:=`, `{` ~ `}` 대신 `begin` ~ `end`를 쓸 수 있습니다. 저는 `:=` 형태를 쓸 수 있다는 것부터가 놀라웠는데, 여기서 끝이 아닙니다.

* `:=`은 `if`문 안에 비교 연산자 `=` 대신으로도 쓸 수 있습니다. 기능은 여전히 비교 연산자입니다.
    * `==`을 `:=:=`으로 쓰는 건 당연히 안 됩니다.
* `{` ~ `end`, `begin` ~ `}`도 허용됩니다.
* 둘 다 게임메이커 8.x 시절부터 허용되는 문법이지만(7.x 이전에 어땠는지는 모르겠습니다) 의외로 겜스 2에 와서야 도움말 페이지에 문서화가 되었습니다. 이전에는 도움말에서 이에 대한 언급이 없었던 것으로 알고 있습니다.

가독성 향상을 위해 변수를 최초로 선언할 때는 `:=`, 수정할 때는 `=`를 쓰는 것도 괜찮아 보입니다.

## `degtorad`를 멀리하고 `dsin`을 가까이

굳이 겜메/겜스 맥락이 아니더라도 삼각함수($$\sin$$, $$\cos$$, ...)는 별 말이 없으면 육십분법 대신 호도법을 씁니다. 육십분법은 $$360^\circ$$가 한 바퀴인, 우리가 일상적으로 사용하는 각도 체계고, 호도법은 $$2\pi \, \mathrm{rad}$$가 한 바퀴인 각도 체계입니다.

겜스에서도 삼각함수(`sin`, `cos`, `tan`, `arcsin`, `arccos`, `arctan`, `arctan2`)는 전부 호도법을 쓰는데, 이들 7개 함수 전부 앞에 `d`를 붙이면(`dsin`, `dcos`, `dtan`, `darcsin`, `darccos`, `darctan`, `darctan2`) 육십분법을 쓰는 함수가 됩니다(겜메는 안 됩니다). 즉, `sin(pi)`, `sin(degtorad(180))`, `dsin(180)`은 전부 같은 의미입니다.

[^fn_js_bigint]: 사실 자바스크립트는 ES2020부터 `BigInt`를 지원합니다. 표현 가능한 범위가 무한한 정수형인데, 이 글에서는 중요한 부분이 아니니 넘어갑시다.