---
layout: post
title: "LIS 알고리즘은 왜 그렇게 헷갈리는 걸까?"
categories:
- Beta
tags:
- Algorithm
- Interactive
style: "/assets/post-styles/why-is-lis-algorithm-so-confusing.css"
script: "/assets/post-scripts/why-is-lis-algorithm-so-confusing.js"
# comments: true
---

**이 글은 링크가 있어야 읽을 수 있는 베타 버전입니다.** 피드백을 받고 있으니 재밌게 읽어주세요 🙇‍♂️

[**가장 긴 증가하는 부분 수열**](https://ko.wikipedia.org/wiki/%EC%B5%9C%EC%9E%A5_%EC%A6%9D%EA%B0%80_%EB%B6%80%EB%B6%84_%EC%88%98%EC%97%B4)(longest increasing subsequence; LIS)은 어떤 수열이 주어질 때 그 수열의 증가하는 부분 수열(연속하지 않아도 됩니다) 중 가장 긴 것을 찾는 문제입니다. 이 문제를 푸는 여러 가지 알고리즘이 알려져 있지만 이 중 가장 빠른 것은 $$O(n \log n)$$입니다.

최근에 트위터에서 지인분이 이 $$O(n \log n)$$ 알고리즘에 대해 얘기한 걸 봤는데, 허락을 받아[^fn-protected-tweet] 내용을 옮기면 다음과 같습니다.

> 이분탐색으로 LIS를 O(nlogn)에 푸는 풀이에서 몇년째 이해 안되는 부분:<br>\- "이분탐색을 이용하여 LIS를 유지하기 위한 최적의 위치에다가 수를 삽입하는 방식"이라는데 그러면 대체 이 배열은 뭘 의미하나<br>이게 LIS를 만드는 것도 아닌데

마침 저도 이 알고리즘을 처음 배우면서 비슷하게 의아했던 점이 생각났기 때문에 블로그 글로 올려보려고 합니다.

---

이 알고리즘이 밟는 단계는 다음과 같습니다.

* 문제의 배열 $$M$$을 만든다.
* $$a$$의 각 원소 $$x$$에 대해...
	* $$M$$의 원소 중 $$x$$ 이상인 가장 작은 것을 찾아 $$x$$로 바꾼다. 보통 이분 탐색을 이용한다.
	* 그런 원소가 없으면 $$M$$의 맨 뒤에 추가한다.
* $$M$$의 길이가 LIS의 길이이다. (왜???)

아무래도 과정이 다소 뜬금없이 느껴지는데, 구글링을 해봐도 읽기 쉽고 속 시원한 답을 제시해주지는 않습니다.

# 어려운 설명

영문판 위키백과의 설명을 옮기면 $$M$$은 다음을 만족하는 배열입니다. 여기서는 수열을 $$a_i$$ 대신 $$X[i]$$로 표기하고 있습니다.

> 그러면 $$X[i]$$를 처리한 뒤에는 … $$M[j]$$ &mdash; $$K ≤ i$$의 범위에서 길이가 $$j$$이고 $$X[k]$$에서 끝나는 증가하는 부분수열이 존재하도록 하는 가장 작은 값 $$X[k]$$의 인덱스 $$k$$를 저장한다. (문장을 명확하게 다듬어야 함)
>
> Then, after processing $$X[i]$$, … $$M[j]$$ &mdash; stores the index $$k$$ of the smallest value $$X[k]$$ such that there is an increasing subsequence of length $$j$$ ending at $$X[k]$$ on the range $$k ≤ i$$ (Need to make this statement clearer).

이 설명을 바탕으로 이 알고리즘을 이해해보려고 한다면 다음과 같습니다.

수열의 어떤 원소 $$x$$를 처리하고 있다고 해 봅시다. 이때 배열 $$M$$을 $$a_{M[i]} < x$$인 부분과 $$a_{M[i]} \ge x$$인 부분으로 나눌 수 있습니다.

* 전자의 경우 $$M[i]$$를 덮어쓰려고 하면 $$a_{M[i]} < x$$이므로 $$M$$의 "가장 작은 값" 조건이 깨집니다.
* 후자의 경우 $$a_{M[i]}$$로 끝나는 부분수열 $$b$$에 대해(위 조건에 대해 존재가 보장됩니다) $$b$$의 맨 끝에 $$x$$를 삽입하려고 하면(즉, $$M[i + 1]$$을 덮어쓰려고 하면) $$a_{M[i]} \ge x$$이므로 LIS 상태가 깨집니다.

그러므로 $$x$$가 들어갈 곳은 $$a_{M[i]} \ge x$$를 만족하는 첫 위치 하나뿐이 됩니다. $$a_{M[i]} \ge x$$으로부터 $$\min \left( a_{M[i]}, x \right) = x$$인 것을 생각하면...

아니다, **지금까지 했던 설명은 그냥 잊어주세요.** 의아한 점에 대해서 설명하고 있는데 최소한 이 위에서 한 헷갈리는 말보다는 쉽게 설명해야죠. 다행히 방법이 있습니다.

# 조금 더 쉬운 설명

**LIS를 구성하는 과정을 트리로 만든다면** 어떻게 될까요?

<div data-script='{}'></div>

**바로 위의 이 애니메이션은 인터랙티브입니다!** 원하는 수열을 공백이나 콤마로 구분해서 입력하고 `적용`을 눌러보세요. 버튼이나 슬라이더를 이용해 재생해볼 수 있습니다. 공간상의 문제로 -999 이상 9999 이하의 정수만 지원합니다.

DP 알고리즘 설명을 보면 부분 문제를 *$$x$$번째 원소로 끝나는 부분 수열*로 잡는 경우를 종종 볼 수 있고, 이 경우에는 보통 기존의 부분 문제의 맨 끝에 $$x$$번째 원소를 하나 더 붙이거나 여의치 않으면 $$x$$번째 원소만 있는 부분 수열이 해가 됩니다.

"맨 끝에 하나 더 붙인다"고 하니 트리로 만들어보기 좋겠네요. 이 방법으로 *LIS 트리*(급조한 이름입니다)를 만들어 봅시다. 루트는 가상의 "0번째" 원소, 즉 $$-\infty$$고 수열의 각 원소가 *자기 자신으로 끝나는 LIS를 이루기 좋은 곳*에 자식으로 붙습니다. 모든 원소는 수열에 등장하는 순서대로 처리되므로 순서가 꼬여서 LIS를 이루지 않는 경우는 없습니다.

LIS의 정의에 의해 모든 부모 노드의 값 $$p$$와 자식 노드의 값 $$c$$의 쌍에 대해 $$p < c$$가 성립하고, 루트 노드의 깊이(depth)를 0으로 정의하면 각 노드의 깊이가 그대로 LIS의 길이가 됩니다.

## 트리를 만드는 규칙

아까 "LIS를 이루기 좋은 곳"이 어딘지 안 말하고 넘어갔는데, LIS 트리의 성질을 보면서 차근차근 생각해 봅시다.

LIS를 최대한 길게 만들려면 가능한 한 가장 깊은 노드를 찾아 자식으로 붙는 것이 제일 좋겠죠. 그런데 어떤 하나의 깊이에서 모든 노드의 값이 너무 커서 자식으로 붙을 수 없는 경우를 생각해볼 수 있습니다. 가장 작은 노드에 붙을 수 없으면 그것보다 더 큰 노드에도 당연히 붙을 수 없으니 깊이별로 **최솟값 노드**를 기록해 둡시다. 새로 붙일 노드와 최솟값을 비교해서 전자가 후자 이하면 그 깊이는 볼 필요도 없이 넘어가면 되겠네요.

노드가 너무 큰 경우를 제외하고 난 뒤에는 남은 노드 중에 붙을 만한 것을 찾아야 되는데, 이때도 아까 기록해 둔 **최솟값 노드**를 요긴하게 쓸 수 있습니다. 위 문단에서 자식으로 붙일 만한 노드가 있는지를 최솟값 노드로 판정했으니 이 판정을 통과했다면 최솟값 노드에는 반드시 붙일 수 있음을 알 수 있습니다.

위의 두 문단에서 얘기한 것을 종합하면 새로운 노드는...

1. **트리에 있는 모든 노드의 깊이를 고려해서**
1. **최솟값 노드가 자신보다 작은 것을 고른 뒤** ($$p < c$$ 제한에 의해)
1. **남은 것 중 가장 깊은 깊이의** (LIS의 길이를 최대화하기 위해)
1. **최솟값 노드** (여기에는 붙일 수 있음이 보장되므로)

에 자식으로 붙는다는 규칙을 만들어볼 수 있습니다. 이 규칙을 염두에 두면서 애니메이션을 다시 재생해보고 오는 것도 좋겠습니다.

## LIS 트리에서 발견한 LIS 알고리즘

마지막으로 할 것은 2~3번 과정을 최적화하는 것입니다. $$p < c$$ 제한을 적용해보면 **최솟값이 $$m$$이면 그 다음 최솟값은 $$m$$보다 클 수밖에 없다**는 것을 알 수 있습니다. 같은 깊이의 모든 노드 $$p$$에 대해서 $$m \le p$$가 성립하므로 그 자식 $$c$$는 $$m \le p < c$$여야 합니다. 즉, **최솟값 노드의 배열은 증가수열이고 오름차순 정렬**되어 있습니다. 이 성질이 없었다면 배열의 가장 깊은 곳부터 하나씩 확인할 수밖에 없는데, 이제는 정렬되어 있다는 것을 알고 있으니 이분 탐색을 쓸 수 있겠네요. "가상의 0번 원소"는 어차피 무엇과 비교해도 더 작으니 이분 탐색에서 제외해도 되겠습니다.

이쯤에서 LIS 트리를 만드는 규칙을 다시 한 번 살펴봅시다.

1. **트리에 있는 모든 노드의 깊이를 고려해서**
1. **최솟값 노드가 자신보다 작은 것을 고른 뒤** ($$p < c$$ 제한에 의해)
1. **남은 것 중 가장 깊은 깊이의** (LIS의 길이를 최대화하기 위해)
1. **최솟값 노드** (여기에는 붙일 수 있음이 보장되므로)

이 규칙만 따르면 **최솟값이 아닌 노드는 확인할 필요가 없습니다**. 나머지 노드를 버리면 최솟값 노드의 배열만 남는데, 뭔가 익숙하게 느껴진다면 바로 맨 처음에 언급한 **문제의 배열 $$M$$**입니다. 규칙을 $$M$$ 위주로 다시 써 볼까요?

1. **배열 $$M$$ 전체에서**
1. **자신보다 작은 마지막 원소를 이분 탐색으로 찾은 뒤**
1. **그 다음 위치를 업데이트**

여기서 2~3번 과정을 더 줄일 수 있습니다.

1. **배열 $$M$$ 전체에서**
1. **자신 이상인 첫 원소를 이분 탐색으로 찾아서** (즉, [`std::lower_bound`](https://en.cppreference.com/w/cpp/algorithm/lower_bound))
1. **업데이트**

글의 맨 위에서 봤던 $$O(n \log n)$$ LIS 알고리즘을 재발견했네요!

# LIS 트리의 그림자

지금까지 했던 "조금 더 쉬운 설명"과 위키백과에서 했던 "어려운 설명"을 비교해보면 사실 같은 것을 말하고 있음을 알 수 있습니다. 그런데 개인적으로는 LIS 트리를 쓰는 설명이 더 쉽게 느껴지네요. 사실 글을 쓰는 제가 생각한 방법이라서 여러분도 그렇게 느끼셨는지는 잘 모르겠습니다. 피드백을 좀 받아봐야지

저에게 위키백과식 설명이 어렵게 느껴졌던 이유는 배열 $$M$$이 LIS 트리에서 따라오는 개념인데 LIS 트리를 언급하지 않고 바로 $$M$$으로 넘어갔기 때문이라고 생각하고 있습니다. 말하자면 **배열 $$M$$은 LIS 트리의 그림자**인 셈이죠. 그림자만 보고 전체를 파악하기란 어려울 수밖에 없습니다.

LIS 트리를 이해했다면 [백준 14003번](https://www.acmicpc.net/problem/14003) 같은 문제에도 응용할 수 있습니다. LIS 트리의 모든 노드는 ("가상의 0번 원소"를 제외하고) 부모가 정확히 하나씩이니 $$O(n)$$짜리 부모 배열을 하나 만들어놓고 LIS 트리를 완성한 뒤에 타고 내려가면 LIS를 복구할 수 있겠죠. 아쉽지만 코드는 올리지 않겠습니다(😰).

[^fn-protected-tweet]: 해당 계정은 트윗을 비공개로 설정하고 있습니다.