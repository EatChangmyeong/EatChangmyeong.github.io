(() => {

mu_parser = // Generated by Peggy 1.2.0.
//
// https://peggyjs.org/
(function() {
	"use strict";

	function peg$subclass(child, parent) {
		function C() { this.constructor = child; }
		C.prototype = parent.prototype;
		child.prototype = new C();
	}

	function peg$SyntaxError(message, expected, found, location) {
		var self = Error.call(this, message);
		if (Object.setPrototypeOf) {
			Object.setPrototypeOf(self, peg$SyntaxError.prototype);
		}
		self.expected = expected;
		self.found = found;
		self.location = location;
		self.name = "SyntaxError";
		return self;
	}

	peg$subclass(peg$SyntaxError, Error);

	function peg$padEnd(str, targetLength, padString) {
		padString = padString || " ";
		if (str.length > targetLength) { return str; }
		targetLength -= str.length;
		padString += padString.repeat(targetLength);
		return str + padString.slice(0, targetLength);
	}

	peg$SyntaxError.prototype.format = function(sources) {
		var str = "Error: " + this.message;
		if (this.location) {
			var src = null;
			var k;
			for (k = 0; k < sources.length; k++) {
				if (sources[k].source === this.location.source) {
					src = sources[k].text.split(/\r\n|\n|\r/g);
					break;
				}
			}
			var s = this.location.start;
			var loc = this.location.source + ":" + s.line + ":" + s.column;
			if (src) {
				var e = this.location.end;
				var filler = peg$padEnd("", s.line.toString().length, ' ');
				var line = src[s.line - 1];
				var last = s.line === e.line ? e.column : line.length + 1;
				str += "\n --> " + loc + "\n"
						+ filler + " |\n"
						+ s.line + " | " + line + "\n"
						+ filler + " | " + peg$padEnd("", s.column - 1, ' ')
						+ peg$padEnd("", last - s.column, "^");
			} else {
				str += "\n at " + loc;
			}
		}
		return str;
	};

	peg$SyntaxError.buildMessage = function(expected, found) {
		var DESCRIBE_EXPECTATION_FNS = {
			literal: function(expectation) {
				return "\"" + literalEscape(expectation.text) + "\"";
			},

			class: function(expectation) {
				var escapedParts = expectation.parts.map(function(part) {
					return Array.isArray(part)
						? classEscape(part[0]) + "-" + classEscape(part[1])
						: classEscape(part);
				});

				return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
			},

			any: function() {
				return "any character";
			},

			end: function() {
				return "end of input";
			},

			other: function(expectation) {
				return expectation.description;
			}
		};

		function hex(ch) {
			return ch.charCodeAt(0).toString(16).toUpperCase();
		}

		function literalEscape(s) {
			return s
				.replace(/\\/g, "\\\\")
				.replace(/"/g,  "\\\"")
				.replace(/\0/g, "\\0")
				.replace(/\t/g, "\\t")
				.replace(/\n/g, "\\n")
				.replace(/\r/g, "\\r")
				.replace(/[\x00-\x0F]/g,          function(ch) { return "\\x0" + hex(ch); })
				.replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return "\\x"  + hex(ch); });
		}

		function classEscape(s) {
			return s
				.replace(/\\/g, "\\\\")
				.replace(/\]/g, "\\]")
				.replace(/\^/g, "\\^")
				.replace(/-/g,  "\\-")
				.replace(/\0/g, "\\0")
				.replace(/\t/g, "\\t")
				.replace(/\n/g, "\\n")
				.replace(/\r/g, "\\r")
				.replace(/[\x00-\x0F]/g,          function(ch) { return "\\x0" + hex(ch); })
				.replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return "\\x"  + hex(ch); });
		}

		function describeExpectation(expectation) {
			return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
		}

		function describeExpected(expected) {
			var descriptions = expected.map(describeExpectation);
			var i, j;

			descriptions.sort();

			if (descriptions.length > 0) {
				for (i = 1, j = 1; i < descriptions.length; i++) {
					if (descriptions[i - 1] !== descriptions[i]) {
						descriptions[j] = descriptions[i];
						j++;
					}
				}
				descriptions.length = j;
			}

			switch (descriptions.length) {
				case 1:
					return descriptions[0];

				case 2:
					return descriptions[0] + " or " + descriptions[1];

				default:
					return descriptions.slice(0, -1).join(", ")
						+ ", or "
						+ descriptions[descriptions.length - 1];
			}
		}

		function describeFound(found) {
			return found ? "\"" + literalEscape(found) + "\"" : "end of input";
		}

		return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
	};

	function peg$parse(input, options) {
		options = options !== undefined ? options : {};

		var peg$FAILED = {};
		var peg$source = options.grammarSource;

		var peg$startRuleFunctions = { MuProgram: peg$parseMuProgram };
		var peg$startRuleFunction = peg$parseMuProgram;

		var peg$c0 = "=";
		var peg$c1 = ";";
		var peg$c2 = "*";
		var peg$c3 = "<";
		var peg$c4 = ">";
		var peg$c5 = "C";
		var peg$c6 = ",";
		var peg$c7 = "S";
		var peg$c8 = "P";
		var peg$c9 = "Rho";
		var peg$c10 = "Mu";

		var peg$r0 = /^[A-Za-z_]/;
		var peg$r1 = /^[A-Za-z0-9_]/;
		var peg$r2 = /^[0-9]/;
		var peg$r3 = /^[ \t\r\n]/;

		var peg$e0 = peg$otherExpectation("function declaration");
		var peg$e1 = peg$literalExpectation("=", false);
		var peg$e2 = peg$literalExpectation(";", false);
		var peg$e3 = peg$otherExpectation("function expression");
		var peg$e4 = peg$literalExpectation("*", false);
		var peg$e5 = peg$literalExpectation("<", false);
		var peg$e6 = peg$literalExpectation(">", false);
		var peg$e7 = peg$otherExpectation("atom");
		var peg$e8 = peg$literalExpectation("C", false);
		var peg$e9 = peg$literalExpectation(",", false);
		var peg$e10 = peg$literalExpectation("S", false);
		var peg$e11 = peg$literalExpectation("P", false);
		var peg$e12 = peg$literalExpectation("Rho", false);
		var peg$e13 = peg$literalExpectation("Mu", false);
		var peg$e14 = peg$otherExpectation("function list");
		var peg$e15 = peg$otherExpectation("identifier");
		var peg$e16 = peg$classExpectation([["A", "Z"], ["a", "z"], "_"], false, false);
		var peg$e17 = peg$classExpectation([["A", "Z"], ["a", "z"], ["0", "9"], "_"], false, false);
		var peg$e18 = peg$otherExpectation("integer");
		var peg$e19 = peg$classExpectation([["0", "9"]], false, false);
		var peg$e20 = peg$otherExpectation("whitespace");
		var peg$e21 = peg$classExpectation([" ", "\t", "\r", "\n"], false, false);

		var peg$f0 = function(fn, int) { return int; };
		var peg$f1 = function(fn, args) {
				if(fn.arity != BigInt(args.length))
					error('number of arguments does not match the function\'s arity');
				return fn.invoke(args.map(x => C(0, x).invoke([])));
			};
		var peg$f2 = function(ident, fn) {
				if(def_map.has(ident))
					error(`${ident} was already defined`);
				def_map.set(ident, fn);
			};
		var peg$f3 = function(base, chain) { return { chain: [chain] }; };
		var peg$f4 = function(base, chain) { return { chain }; };
		var peg$f5 = function(base, arity) { return { chain: [], arity }; };
		var peg$f6 = function(base, chain) { return chain; };
		var peg$f7 = function(base, chain) {
				for(const x of chain)
					if(base.arity != 0n && 'arity' in x)
						error('*: non-nullary function cannot be nullary chained');
					else if(base.arity == 0n && !('arity' in x))
						error('*: nullary function cannot be non-nullary chained');
					else if(base.arity != BigInt(x.chain.length))
						error('*: arity mismatch between underlying functions');
					else if(base.arity == 0n)
						base = compose_nullary(base, x.arity);
					else
						base = compose(base, x.chain);
				return base;
			};
		var peg$f8 = function(arity, value) {
				return C(arity, value);
			};
		var peg$f9 = function() { return S; };
		var peg$f10 = function(arity, index) {
				if(arity == 0n)
					error('P: a projection function cannot be nullary');
				if(index >= arity)
					error('P: return index must be less than its arity');
				return P(arity, index);
			};
		var peg$f11 = function(base, iter) {
				if(base.arity + 2n != iter.arity)
					error('Rho: arity mismatch between underlying functions');
				return rho(base, iter);
			};
		var peg$f12 = function(iter) {
				if(iter.arity == 0n)
					error('Mu: underlying function must not be nullary');
				return mu(iter);
			};
		var peg$f13 = function(ident) {
				if(!def_map.has(ident))
					error(`${ident} is not defined`);
				return def_map.get(ident);
			};
		var peg$f14 = function(fn, next) { return next; };
		var peg$f15 = function(fn, rest) { return [fn, ...rest]; };
		var peg$f16 = function(ident) {
				return (
					ident == 'C' ||
					ident == 'S' ||
					ident == 'P' ||
					ident == 'Mu' ||
					ident == 'Rho'
				);
			};
		var peg$f17 = function(ident) { return ident; };
		var peg$f18 = function(int) { return BigInt(int); };

		var peg$currPos = 0;
		var peg$savedPos = 0;
		var peg$posDetailsCache = [{ line: 1, column: 1 }];
		var peg$maxFailPos = 0;
		var peg$maxFailExpected = [];
		var peg$silentFails = 0;

		var peg$result;

		if ("startRule" in options) {
			if (!(options.startRule in peg$startRuleFunctions)) {
				throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
			}

			peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
		}

		function text() {
			return input.substring(peg$savedPos, peg$currPos);
		}

		function offset() {
			return peg$savedPos;
		}

		function range() {
			return {
				source: peg$source,
				start: peg$savedPos,
				end: peg$currPos
			};
		}

		function location() {
			return peg$computeLocation(peg$savedPos, peg$currPos);
		}

		function expected(description, location) {
			location = location !== undefined
				? location
				: peg$computeLocation(peg$savedPos, peg$currPos);

			throw peg$buildStructuredError(
				[peg$otherExpectation(description)],
				input.substring(peg$savedPos, peg$currPos),
				location
			);
		}

		function error(message, location) {
			location = location !== undefined
				? location
				: peg$computeLocation(peg$savedPos, peg$currPos);

			throw peg$buildSimpleError(message, location);
		}

		function peg$literalExpectation(text, ignoreCase) {
			return { type: "literal", text: text, ignoreCase: ignoreCase };
		}

		function peg$classExpectation(parts, inverted, ignoreCase) {
			return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
		}

		function peg$anyExpectation() {
			return { type: "any" };
		}

		function peg$endExpectation() {
			return { type: "end" };
		}

		function peg$otherExpectation(description) {
			return { type: "other", description: description };
		}

		function peg$computePosDetails(pos) {
			var details = peg$posDetailsCache[pos];
			var p;

			if (details) {
				return details;
			} else {
				p = pos - 1;
				while (!peg$posDetailsCache[p]) {
					p--;
				}

				details = peg$posDetailsCache[p];
				details = {
					line: details.line,
					column: details.column
				};

				while (p < pos) {
					if (input.charCodeAt(p) === 10) {
						details.line++;
						details.column = 1;
					} else {
						details.column++;
					}

					p++;
				}

				peg$posDetailsCache[pos] = details;

				return details;
			}
		}

		function peg$computeLocation(startPos, endPos) {
			var startPosDetails = peg$computePosDetails(startPos);
			var endPosDetails = peg$computePosDetails(endPos);

			return {
				source: peg$source,
				start: {
					offset: startPos,
					line: startPosDetails.line,
					column: startPosDetails.column
				},
				end: {
					offset: endPos,
					line: endPosDetails.line,
					column: endPosDetails.column
				}
			};
		}

		function peg$fail(expected) {
			if (peg$currPos < peg$maxFailPos) { return; }

			if (peg$currPos > peg$maxFailPos) {
				peg$maxFailPos = peg$currPos;
				peg$maxFailExpected = [];
			}

			peg$maxFailExpected.push(expected);
		}

		function peg$buildSimpleError(message, location) {
			return new peg$SyntaxError(message, null, null, location);
		}

		function peg$buildStructuredError(expected, found, location) {
			return new peg$SyntaxError(
				peg$SyntaxError.buildMessage(expected, found),
				expected,
				found,
				location
			);
		}

		function peg$parseMuProgram() {
			var s0, s1, s2, s3, s4, s5, s6;

			s0 = peg$currPos;
			s1 = [];
			s2 = peg$currPos;
			s3 = peg$parseDef();
			if (s3 !== peg$FAILED) {
				s4 = peg$parse_();
				s3 = [s3, s4];
				s2 = s3;
			} else {
				peg$currPos = s2;
				s2 = peg$FAILED;
			}
			while (s2 !== peg$FAILED) {
				s1.push(s2);
				s2 = peg$currPos;
				s3 = peg$parseDef();
				if (s3 !== peg$FAILED) {
					s4 = peg$parse_();
					s3 = [s3, s4];
					s2 = s3;
				} else {
					peg$currPos = s2;
					s2 = peg$FAILED;
				}
			}
			s2 = peg$parseFn();
			if (s2 !== peg$FAILED) {
				s3 = [];
				s4 = peg$currPos;
				s5 = peg$parse_();
				s6 = peg$parseint();
				if (s6 !== peg$FAILED) {
					peg$savedPos = s4;
					s4 = peg$f0(s2, s6);
				} else {
					peg$currPos = s4;
					s4 = peg$FAILED;
				}
				while (s4 !== peg$FAILED) {
					s3.push(s4);
					s4 = peg$currPos;
					s5 = peg$parse_();
					s6 = peg$parseint();
					if (s6 !== peg$FAILED) {
						peg$savedPos = s4;
						s4 = peg$f0(s2, s6);
					} else {
						peg$currPos = s4;
						s4 = peg$FAILED;
					}
				}
				peg$savedPos = s0;
				s0 = peg$f1(s2, s3);
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}

			return s0;
		}

		function peg$parseDef() {
			var s0, s1, s2, s3, s4, s5, s6, s7;

			peg$silentFails++;
			s0 = peg$currPos;
			s1 = peg$parseident();
			if (s1 !== peg$FAILED) {
				s2 = peg$parse_();
				if (input.charCodeAt(peg$currPos) === 61) {
					s3 = peg$c0;
					peg$currPos++;
				} else {
					s3 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$e1); }
				}
				if (s3 !== peg$FAILED) {
					s4 = peg$parse_();
					s5 = peg$parseFn();
					if (s5 !== peg$FAILED) {
						s6 = peg$parse_();
						if (input.charCodeAt(peg$currPos) === 59) {
							s7 = peg$c1;
							peg$currPos++;
						} else {
							s7 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$e2); }
						}
						if (s7 !== peg$FAILED) {
							peg$savedPos = s0;
							s0 = peg$f2(s1, s5);
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
			peg$silentFails--;
			if (s0 === peg$FAILED) {
				s1 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e0); }
			}

			return s0;
		}

		function peg$parseFn() {
			var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;

			peg$silentFails++;
			s0 = peg$currPos;
			s1 = peg$parseAtom();
			if (s1 !== peg$FAILED) {
				s2 = [];
				s3 = peg$currPos;
				s4 = peg$parse_();
				if (input.charCodeAt(peg$currPos) === 42) {
					s5 = peg$c2;
					peg$currPos++;
				} else {
					s5 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$e4); }
				}
				if (s5 !== peg$FAILED) {
					s6 = peg$parse_();
					s7 = peg$currPos;
					s8 = peg$parseAtom();
					if (s8 !== peg$FAILED) {
						peg$savedPos = s7;
						s8 = peg$f3(s1, s8);
					}
					s7 = s8;
					if (s7 === peg$FAILED) {
						s7 = peg$currPos;
						if (input.charCodeAt(peg$currPos) === 60) {
							s8 = peg$c3;
							peg$currPos++;
						} else {
							s8 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$e5); }
						}
						if (s8 !== peg$FAILED) {
							s9 = peg$parse_();
							s10 = peg$parseFnList();
							if (s10 !== peg$FAILED) {
								s11 = peg$parse_();
								if (input.charCodeAt(peg$currPos) === 62) {
									s12 = peg$c4;
									peg$currPos++;
								} else {
									s12 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$e6); }
								}
								if (s12 !== peg$FAILED) {
									peg$savedPos = s7;
									s7 = peg$f4(s1, s10);
								} else {
									peg$currPos = s7;
									s7 = peg$FAILED;
								}
							} else {
								peg$currPos = s7;
								s7 = peg$FAILED;
							}
						} else {
							peg$currPos = s7;
							s7 = peg$FAILED;
						}
						if (s7 === peg$FAILED) {
							s7 = peg$currPos;
							if (input.charCodeAt(peg$currPos) === 60) {
								s8 = peg$c3;
								peg$currPos++;
							} else {
								s8 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$e5); }
							}
							if (s8 !== peg$FAILED) {
								s9 = peg$parse_();
								s10 = peg$parseint();
								if (s10 !== peg$FAILED) {
									s11 = peg$parse_();
									if (input.charCodeAt(peg$currPos) === 62) {
										s12 = peg$c4;
										peg$currPos++;
									} else {
										s12 = peg$FAILED;
										if (peg$silentFails === 0) { peg$fail(peg$e6); }
									}
									if (s12 !== peg$FAILED) {
										peg$savedPos = s7;
										s7 = peg$f5(s1, s10);
									} else {
										peg$currPos = s7;
										s7 = peg$FAILED;
									}
								} else {
									peg$currPos = s7;
									s7 = peg$FAILED;
								}
							} else {
								peg$currPos = s7;
								s7 = peg$FAILED;
							}
						}
					}
					if (s7 !== peg$FAILED) {
						peg$savedPos = s3;
						s3 = peg$f6(s1, s7);
					} else {
						peg$currPos = s3;
						s3 = peg$FAILED;
					}
				} else {
					peg$currPos = s3;
					s3 = peg$FAILED;
				}
				while (s3 !== peg$FAILED) {
					s2.push(s3);
					s3 = peg$currPos;
					s4 = peg$parse_();
					if (input.charCodeAt(peg$currPos) === 42) {
						s5 = peg$c2;
						peg$currPos++;
					} else {
						s5 = peg$FAILED;
						if (peg$silentFails === 0) { peg$fail(peg$e4); }
					}
					if (s5 !== peg$FAILED) {
						s6 = peg$parse_();
						s7 = peg$currPos;
						s8 = peg$parseAtom();
						if (s8 !== peg$FAILED) {
							peg$savedPos = s7;
							s8 = peg$f3(s1, s8);
						}
						s7 = s8;
						if (s7 === peg$FAILED) {
							s7 = peg$currPos;
							if (input.charCodeAt(peg$currPos) === 60) {
								s8 = peg$c3;
								peg$currPos++;
							} else {
								s8 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$e5); }
							}
							if (s8 !== peg$FAILED) {
								s9 = peg$parse_();
								s10 = peg$parseFnList();
								if (s10 !== peg$FAILED) {
									s11 = peg$parse_();
									if (input.charCodeAt(peg$currPos) === 62) {
										s12 = peg$c4;
										peg$currPos++;
									} else {
										s12 = peg$FAILED;
										if (peg$silentFails === 0) { peg$fail(peg$e6); }
									}
									if (s12 !== peg$FAILED) {
										peg$savedPos = s7;
										s7 = peg$f4(s1, s10);
									} else {
										peg$currPos = s7;
										s7 = peg$FAILED;
									}
								} else {
									peg$currPos = s7;
									s7 = peg$FAILED;
								}
							} else {
								peg$currPos = s7;
								s7 = peg$FAILED;
							}
							if (s7 === peg$FAILED) {
								s7 = peg$currPos;
								if (input.charCodeAt(peg$currPos) === 60) {
									s8 = peg$c3;
									peg$currPos++;
								} else {
									s8 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$e5); }
								}
								if (s8 !== peg$FAILED) {
									s9 = peg$parse_();
									s10 = peg$parseint();
									if (s10 !== peg$FAILED) {
										s11 = peg$parse_();
										if (input.charCodeAt(peg$currPos) === 62) {
											s12 = peg$c4;
											peg$currPos++;
										} else {
											s12 = peg$FAILED;
											if (peg$silentFails === 0) { peg$fail(peg$e6); }
										}
										if (s12 !== peg$FAILED) {
											peg$savedPos = s7;
											s7 = peg$f5(s1, s10);
										} else {
											peg$currPos = s7;
											s7 = peg$FAILED;
										}
									} else {
										peg$currPos = s7;
										s7 = peg$FAILED;
									}
								} else {
									peg$currPos = s7;
									s7 = peg$FAILED;
								}
							}
						}
						if (s7 !== peg$FAILED) {
							peg$savedPos = s3;
							s3 = peg$f6(s1, s7);
						} else {
							peg$currPos = s3;
							s3 = peg$FAILED;
						}
					} else {
						peg$currPos = s3;
						s3 = peg$FAILED;
					}
				}
				peg$savedPos = s0;
				s0 = peg$f7(s1, s2);
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
			peg$silentFails--;
			if (s0 === peg$FAILED) {
				s1 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e3); }
			}

			return s0;
		}

		function peg$parseAtom() {
			var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

			peg$silentFails++;
			s0 = peg$currPos;
			if (input.charCodeAt(peg$currPos) === 67) {
				s1 = peg$c5;
				peg$currPos++;
			} else {
				s1 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e8); }
			}
			if (s1 !== peg$FAILED) {
				s2 = peg$parse_();
				if (input.charCodeAt(peg$currPos) === 60) {
					s3 = peg$c3;
					peg$currPos++;
				} else {
					s3 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$e5); }
				}
				if (s3 !== peg$FAILED) {
					s4 = peg$parse_();
					s5 = peg$parseint();
					if (s5 !== peg$FAILED) {
						s6 = peg$parse_();
						if (input.charCodeAt(peg$currPos) === 44) {
							s7 = peg$c6;
							peg$currPos++;
						} else {
							s7 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$e9); }
						}
						if (s7 !== peg$FAILED) {
							s8 = peg$parse_();
							s9 = peg$parseint();
							if (s9 !== peg$FAILED) {
								s10 = peg$parse_();
								if (input.charCodeAt(peg$currPos) === 62) {
									s11 = peg$c4;
									peg$currPos++;
								} else {
									s11 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$e6); }
								}
								if (s11 !== peg$FAILED) {
									peg$savedPos = s0;
									s0 = peg$f8(s5, s9);
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
			if (s0 === peg$FAILED) {
				s0 = peg$currPos;
				if (input.charCodeAt(peg$currPos) === 83) {
					s1 = peg$c7;
					peg$currPos++;
				} else {
					s1 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$e10); }
				}
				if (s1 !== peg$FAILED) {
					peg$savedPos = s0;
					s1 = peg$f9();
				}
				s0 = s1;
				if (s0 === peg$FAILED) {
					s0 = peg$currPos;
					if (input.charCodeAt(peg$currPos) === 80) {
						s1 = peg$c8;
						peg$currPos++;
					} else {
						s1 = peg$FAILED;
						if (peg$silentFails === 0) { peg$fail(peg$e11); }
					}
					if (s1 !== peg$FAILED) {
						s2 = peg$parse_();
						if (input.charCodeAt(peg$currPos) === 60) {
							s3 = peg$c3;
							peg$currPos++;
						} else {
							s3 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$e5); }
						}
						if (s3 !== peg$FAILED) {
							s4 = peg$parse_();
							s5 = peg$parseint();
							if (s5 !== peg$FAILED) {
								s6 = peg$parse_();
								if (input.charCodeAt(peg$currPos) === 44) {
									s7 = peg$c6;
									peg$currPos++;
								} else {
									s7 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$e9); }
								}
								if (s7 !== peg$FAILED) {
									s8 = peg$parse_();
									s9 = peg$parseint();
									if (s9 !== peg$FAILED) {
										s10 = peg$parse_();
										if (input.charCodeAt(peg$currPos) === 62) {
											s11 = peg$c4;
											peg$currPos++;
										} else {
											s11 = peg$FAILED;
											if (peg$silentFails === 0) { peg$fail(peg$e6); }
										}
										if (s11 !== peg$FAILED) {
											peg$savedPos = s0;
											s0 = peg$f10(s5, s9);
										} else {
											peg$currPos = s0;
											s0 = peg$FAILED;
										}
									} else {
										peg$currPos = s0;
										s0 = peg$FAILED;
									}
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
					if (s0 === peg$FAILED) {
						s0 = peg$currPos;
						if (input.substr(peg$currPos, 3) === peg$c9) {
							s1 = peg$c9;
							peg$currPos += 3;
						} else {
							s1 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$e12); }
						}
						if (s1 !== peg$FAILED) {
							s2 = peg$parse_();
							if (input.charCodeAt(peg$currPos) === 60) {
								s3 = peg$c3;
								peg$currPos++;
							} else {
								s3 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$e5); }
							}
							if (s3 !== peg$FAILED) {
								s4 = peg$parse_();
								s5 = peg$parseFn();
								if (s5 !== peg$FAILED) {
									s6 = peg$parse_();
									if (input.charCodeAt(peg$currPos) === 44) {
										s7 = peg$c6;
										peg$currPos++;
									} else {
										s7 = peg$FAILED;
										if (peg$silentFails === 0) { peg$fail(peg$e9); }
									}
									if (s7 !== peg$FAILED) {
										s8 = peg$parse_();
										s9 = peg$parseFn();
										if (s9 !== peg$FAILED) {
											s10 = peg$parse_();
											if (input.charCodeAt(peg$currPos) === 62) {
												s11 = peg$c4;
												peg$currPos++;
											} else {
												s11 = peg$FAILED;
												if (peg$silentFails === 0) { peg$fail(peg$e6); }
											}
											if (s11 !== peg$FAILED) {
												peg$savedPos = s0;
												s0 = peg$f11(s5, s9);
											} else {
												peg$currPos = s0;
												s0 = peg$FAILED;
											}
										} else {
											peg$currPos = s0;
											s0 = peg$FAILED;
										}
									} else {
										peg$currPos = s0;
										s0 = peg$FAILED;
									}
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}
						if (s0 === peg$FAILED) {
							s0 = peg$currPos;
							if (input.substr(peg$currPos, 2) === peg$c10) {
								s1 = peg$c10;
								peg$currPos += 2;
							} else {
								s1 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$e13); }
							}
							if (s1 !== peg$FAILED) {
								s2 = peg$parse_();
								if (input.charCodeAt(peg$currPos) === 60) {
									s3 = peg$c3;
									peg$currPos++;
								} else {
									s3 = peg$FAILED;
									if (peg$silentFails === 0) { peg$fail(peg$e5); }
								}
								if (s3 !== peg$FAILED) {
									s4 = peg$parse_();
									s5 = peg$parseFn();
									if (s5 !== peg$FAILED) {
										s6 = peg$parse_();
										if (input.charCodeAt(peg$currPos) === 62) {
											s7 = peg$c4;
											peg$currPos++;
										} else {
											s7 = peg$FAILED;
											if (peg$silentFails === 0) { peg$fail(peg$e6); }
										}
										if (s7 !== peg$FAILED) {
											peg$savedPos = s0;
											s0 = peg$f12(s5);
										} else {
											peg$currPos = s0;
											s0 = peg$FAILED;
										}
									} else {
										peg$currPos = s0;
										s0 = peg$FAILED;
									}
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
							if (s0 === peg$FAILED) {
								s0 = peg$currPos;
								s1 = peg$parseident();
								if (s1 !== peg$FAILED) {
									peg$savedPos = s0;
									s1 = peg$f13(s1);
								}
								s0 = s1;
							}
						}
					}
				}
			}
			peg$silentFails--;
			if (s0 === peg$FAILED) {
				s1 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e7); }
			}

			return s0;
		}

		function peg$parseFnList() {
			var s0, s1, s2, s3, s4, s5, s6, s7;

			peg$silentFails++;
			s0 = peg$currPos;
			s1 = peg$parseFn();
			if (s1 !== peg$FAILED) {
				s2 = [];
				s3 = peg$currPos;
				s4 = peg$parse_();
				if (input.charCodeAt(peg$currPos) === 44) {
					s5 = peg$c6;
					peg$currPos++;
				} else {
					s5 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$e9); }
				}
				if (s5 !== peg$FAILED) {
					s6 = peg$parse_();
					s7 = peg$parseFn();
					if (s7 !== peg$FAILED) {
						peg$savedPos = s3;
						s3 = peg$f14(s1, s7);
					} else {
						peg$currPos = s3;
						s3 = peg$FAILED;
					}
				} else {
					peg$currPos = s3;
					s3 = peg$FAILED;
				}
				while (s3 !== peg$FAILED) {
					s2.push(s3);
					s3 = peg$currPos;
					s4 = peg$parse_();
					if (input.charCodeAt(peg$currPos) === 44) {
						s5 = peg$c6;
						peg$currPos++;
					} else {
						s5 = peg$FAILED;
						if (peg$silentFails === 0) { peg$fail(peg$e9); }
					}
					if (s5 !== peg$FAILED) {
						s6 = peg$parse_();
						s7 = peg$parseFn();
						if (s7 !== peg$FAILED) {
							peg$savedPos = s3;
							s3 = peg$f14(s1, s7);
						} else {
							peg$currPos = s3;
							s3 = peg$FAILED;
						}
					} else {
						peg$currPos = s3;
						s3 = peg$FAILED;
					}
				}
				peg$savedPos = s0;
				s0 = peg$f15(s1, s2);
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
			peg$silentFails--;
			if (s0 === peg$FAILED) {
				s1 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e14); }
			}

			return s0;
		}

		function peg$parseident() {
			var s0, s1, s2, s3, s4, s5;

			peg$silentFails++;
			s0 = peg$currPos;
			s1 = peg$currPos;
			s2 = peg$currPos;
			if (peg$r0.test(input.charAt(peg$currPos))) {
				s3 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s3 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e16); }
			}
			if (s3 !== peg$FAILED) {
				s4 = [];
				if (peg$r1.test(input.charAt(peg$currPos))) {
					s5 = input.charAt(peg$currPos);
					peg$currPos++;
				} else {
					s5 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$e17); }
				}
				while (s5 !== peg$FAILED) {
					s4.push(s5);
					if (peg$r1.test(input.charAt(peg$currPos))) {
						s5 = input.charAt(peg$currPos);
						peg$currPos++;
					} else {
						s5 = peg$FAILED;
						if (peg$silentFails === 0) { peg$fail(peg$e17); }
					}
				}
				s3 = [s3, s4];
				s2 = s3;
			} else {
				peg$currPos = s2;
				s2 = peg$FAILED;
			}
			if (s2 !== peg$FAILED) {
				s1 = input.substring(s1, peg$currPos);
			} else {
				s1 = s2;
			}
			if (s1 !== peg$FAILED) {
				peg$savedPos = peg$currPos;
				s2 = peg$f16(s1);
				if (s2) {
					s2 = peg$FAILED;
				} else {
					s2 = undefined;
				}
				if (s2 !== peg$FAILED) {
					peg$savedPos = s0;
					s0 = peg$f17(s1);
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
			peg$silentFails--;
			if (s0 === peg$FAILED) {
				s1 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e15); }
			}

			return s0;
		}

		function peg$parseint() {
			var s0, s1, s2, s3;

			peg$silentFails++;
			s0 = peg$currPos;
			s1 = peg$currPos;
			s2 = [];
			if (peg$r2.test(input.charAt(peg$currPos))) {
				s3 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s3 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e19); }
			}
			if (s3 !== peg$FAILED) {
				while (s3 !== peg$FAILED) {
					s2.push(s3);
					if (peg$r2.test(input.charAt(peg$currPos))) {
						s3 = input.charAt(peg$currPos);
						peg$currPos++;
					} else {
						s3 = peg$FAILED;
						if (peg$silentFails === 0) { peg$fail(peg$e19); }
					}
				}
			} else {
				s2 = peg$FAILED;
			}
			if (s2 !== peg$FAILED) {
				s1 = input.substring(s1, peg$currPos);
			} else {
				s1 = s2;
			}
			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$f18(s1);
			}
			s0 = s1;
			peg$silentFails--;
			if (s0 === peg$FAILED) {
				s1 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e18); }
			}

			return s0;
		}

		function peg$parse_() {
			var s0, s1;

			peg$silentFails++;
			s0 = [];
			if (peg$r3.test(input.charAt(peg$currPos))) {
				s1 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s1 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$e21); }
			}
			while (s1 !== peg$FAILED) {
				s0.push(s1);
				if (peg$r3.test(input.charAt(peg$currPos))) {
					s1 = input.charAt(peg$currPos);
					peg$currPos++;
				} else {
					s1 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$e21); }
				}
			}
			peg$silentFails--;
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$e20); }

			return s0;
		}


			class MuFunction {
				constructor(arity, fn) {
					this.arity = arity;
					this.fn = function*(arg) {
						yield;
						return yield* fn(arg);
					};
				}
				invoke(arg) {
					return new MuInvocation(this.fn(arg));
				}
			}
			class MuInvocation {
				constructor(gen) {
					this.gen = gen;
					this.result = undefined;
				}
				next() {
					if(this.result === undefined) {
						const { done, value } = this.gen.next();
						if(done && typeof value === 'bigint')
							this.result = value;
						else {
							if(done)
								this.gen = value;
							return { done: false, value: undefined };
						}
					}
					return { done: true, value: this.result };
				}
				[Symbol.iterator]() {
					return this;
				}
			}
			function predicate(arity, fn) {
				return new MuFunction(arity, function*(arg_) {
					const arg = [];
					for(const x of arg_)
						arg.push(yield* x);
					return fn(arg) ? 1n : 0n;
				});
			}

			const
				initial_defs = new Map([
					['__builtin_add', new MuFunction(2n, function*([l, r]) {
						return (yield* l) + (yield* r);
					})],
					['__builtin_sub', new MuFunction(2n, function*([l_, r_]) {
						const
							l = yield* l_,
							r = yield* r_;
						return l >= r ? l - r : 0n;
					})],
					['__builtin_pred', new MuFunction(1n, function*([x_]) {
						const x = yield* x_;
						return x == 0n ? 0n : x - 1n;
					})],
					['__builtin_mul', new MuFunction(2n, function*([l, r]) {
						return (yield* l)*(yield* r);
					})],
					['__builtin_div', new MuFunction(2n, function*([l, r_]) {
						const r = yield* r_;
						if(r == 0n)
							while(true)
								yield;
						return (yield* l)/r;
					})],
					['__builtin_exp', new MuFunction(2n, function*([l, r]) {
						return (yield* l)**(yield* r);
					})],
					['__builtin_eq', predicate(2n, ([l, r]) => l == r)],
					['__builtin_ne', predicate(2n, ([l, r]) => l != r)],
					['__builtin_lt', predicate(2n, ([l, r]) => l < r)],
					['__builtin_le', predicate(2n, ([l, r]) => l <= r)],
					['__builtin_gt', predicate(2n, ([l, r]) => l > r)],
					['__builtin_ge', predicate(2n, ([l, r]) => l >= r)],
					['__builtin_and', predicate(2n, ([l, r]) => l && r)],
					['__builtin_or', predicate(2n, ([l, r]) => l || r)],
					['__builtin_not', predicate(1n, ([x]) => !x)],
					['__builtin_if', new MuFunction(3n, function*([p, t, f]) {
						return yield* ((yield* p) ? t : f);
					})],
				]),
				C = (a, x) => new MuFunction(a, function*() {
					return x;
				}),
				S = new MuFunction(1n, function*([x]) {
					return (yield* x) + 1n;
				}),
				P = (a, i) => new MuFunction(a, function*(arg) {
					return arg[i];
				}),
				compose = (L, r) => new MuFunction(r[0].arity, function*(arg) {
					return L.invoke(r.map((X, i) => X.invoke(arg)));
				}),
				compose_nullary = (L, a) => new MuFunction(a, function*() {
					return L.invoke([]);
				}),
				rho = (F, G) => new MuFunction(
					F.arity + 1n,
					function*([first_, ...rest]) {
						const first = yield* first_;
						if(first == 0n)
							return F.invoke(rest);
						else {
							const first_dec = C(0, first - 1n).invoke();
							return G.invoke([
								first_dec,
								this.invoke([first_dec, ...rest]),
								...rest
							]);
						}
					}
				),
				mu = F => new MuFunction(F.arity - 1n, function*(arg) {
					for(let i = 0n;; i++)
						if((yield* F.invoke([C(0, i).invoke([]), ...arg])) == 0n)
							return i;
				});
			const def_map = new Map(initial_defs);


		peg$result = peg$startRuleFunction();

		if (peg$result !== peg$FAILED && peg$currPos === input.length) {
			return peg$result;
		} else {
			if (peg$result !== peg$FAILED && peg$currPos < input.length) {
				peg$fail(peg$endExpectation());
			}

			throw peg$buildStructuredError(
				peg$maxFailExpected,
				peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
				peg$maxFailPos < input.length
					? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
					: peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
			);
		}
	}

	return {
		SyntaxError: peg$SyntaxError,
		parse: peg$parse
	};
})();

class MuInterpreter {
	constructor(elem) {
		this.running = NaN;
		this.html = this.html(elem);
	}

	html(elem) {
		const
			frag = new DocumentFragment(),
			input = document.createElement('textarea'),
			output_line = document.createElement('div'),
			output = document.createElement('p'),
			run = document.createElement('button'),
			stop = document.createElement('button');
		input.className = 'mu-input';
		input.value =
`add = __builtin_add;
pred = __builtin_pred;
sub = __builtin_sub;
mul = __builtin_mul;
div = __builtin_div;
exp = __builtin_exp;
eq = __builtin_eq;
ne = __builtin_ne;
lt = __builtin_lt;
le = __builtin_le;
gt = __builtin_gt;
ge = __builtin_ge;
and = __builtin_and;
or = __builtin_or;
not = __builtin_not;
if = __builtin_if;

Mu<
	not*gt*<
		mul*<S*P<2, 0>, S*P<2, 0>>,
		P<2, 1>
	>
> 16`;
		frag.append(input);
		output.className = 'mu-output';
		output_line.append(output);
		run.textContent = '실행';
		run.addEventListener('click', () => this.run());
		output_line.append(run);
		stop.textContent = '중지';
		stop.addEventListener('click', () => this.stop(true));
		output_line.append(stop);
		output_line.className = 'mu-output-line';
		frag.append(output_line);
		elem.append(frag);

		return { input, output };
	}

	run() {
		try {
			this.stop();

			const expr = mu_parser.parse(this.html.input.value);
			this.message('...');
			this.running = setInterval(() => {
				try {
					const now = Date.now();
					do {
						const { done, value } = expr.next();
						if(done) {
							this.message(`= ${value}`);
							this.stop();
							break;
						}
					} while(Date.now() - now < 90);
				} catch(e) {
					this.error(e);
					this.stop();
				}
			}, 100);
		} catch(e) {
			this.error(e);
		}
	}
	stop(force = false) {
		if(!Number.isNaN(this.running)) {
			clearInterval(this.running);
			this.running = NaN;
			if(force)
				this.message('Execution stopped.');
		}
	}
	message(str) {
		this.html.output.classList.remove('error');
		this.html.output.textContent = str;
	}
	error(err) {
		this.html.output.classList.add('error');
		this.html.output.textContent = err.message;
	}
}

substitute((e, _) => new MuInterpreter(e));

})();